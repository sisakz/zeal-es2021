<!DOCTYPE html>

<html lang="zh-tw" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from expressjs.com/zh-tw/advanced/best-practice-performance.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 10 Jul 2019 00:23:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<title>在正式作業中使用 Express 的效能最佳作法</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="og:image" content="../../images/express-facebook-share.png">
<link rel="icon" type="image/png" href="../../images/favicon.png" />
<link rel="stylesheet" href="../../css/style.css">
<link rel="stylesheet" href="../../css/dropit.css">
<link rel="stylesheet" href="../../css/prism.css">
<link rel="stylesheet" href="../../css/font-awesome.min.css">
<link rel="stylesheet" href="../../../fonts.googleapis.com/css2a1d.css?family=Open+Sans:300,400,600,700&amp;amp;subset=latin,latin-ext">
<link rel="stylesheet" href="../../css/zh-tw.css">
<link rel="stylesheet" href="../../css/nodeinteractive.css">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script data-cfasync="false" src="../../../ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script data-cfasync="false" src="../../js/ismobile.js"></script>
<script data-cfasync="false" src="../../js/app.js"></script>
<script data-cfasync="false" src="../../js/retina.js"></script>
<script data-cfasync="false" src="../../js/dropit.js"></script>
<script data-cfasync="false" src="../../js/prism.js"></script>
<link rel="stylesheet" href="../../../cdn.jsdelivr.net/npm/docsearch.js%402/dist/cdn/docsearch.min.css" />
</head>
<body class="non-en-doc">
<section class="page content">
<header>
<div id="mobile-menu">
<div id="nav-button" class="fa fa-bars fa-2x button"></div>
</div>
<section id="logo"><a href="../../index.html" class="express">Express</a>
</section>
<div id="navbar">
<input id="q" placeholder="🔎 search">
<ul id="navmenu">
<li><a href="../index.html" id="home-menu">首頁</a></li>
<li>
<ul id="getting-started-menu" class="menu">
<li><a href="../starter/installing.html">入門</a>
<ul>
<li>
<a href="../starter/installing.html">
安裝
</a>
</li>
<li>
<a href="../starter/hello-world.html">
Hello World
</a>
</li>
<li>
<a href="../starter/generator.html">
Express 產生器
</a>
</li>
<li>
<a href="../starter/basic-routing.html">
基本路由
</a>
</li>
<li>
<a href="../starter/static-files.html">
靜態檔案
</a>
</li>
<li>
<a href="../starter/faq.html">
常見問題 (FAQ)
</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<ul id="guide-menu" class="menu">
<li><a href="../guide/routing.html">手冊</a>
<ul>
<li><a href="../guide/routing.html">路由</a>
</li>
<li><a href="../guide/writing-middleware.html">撰寫中介軟體</a>
</li>
<li><a href="../guide/using-middleware.html">使用中介軟體</a>
</li>
<li><a href="../guide/using-template-engines.html">使用範本引擎</a>
</li>
<li><a href="../guide/error-handling.html">錯誤處理</a>
</li>
<li><a href="../guide/debugging.html">除錯</a>
</li>
<li><a href="../guide/behind-proxies.html">位於 Proxy 背後的 Express</a>
</li>
<li><a href="../guide/migrating-4.html">移至 Express 4</a>
</li>
<li><a href="../guide/migrating-5.html">移至 Express 5</a>
</li>
<li><a href="../guide/database-integration.html">資料庫整合</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<ul id="application-menu" class="menu">
<li><a href="../4x/api.html">API 參照</a>
<ul>
<li><a href="../4x/api.html">4.x</a>
</li>
<li><a href="../3x/api.html">3.x（已淘汰）</a>
</li>
<li><a href="../../2x/index.html">2.x（已淘汰）</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<ul id="advanced-topics-menu" class="menu">
<li><a href="developing-template-engines.html" class="active">進階主題</a>
<ul>
<li><a href="developing-template-engines.html">範本引擎</a>
</li>
<li><a href="pm.html">使用程序管理程式</a>
</li>
<li><a href="security-updates.html">安全更新</a>
</li>
<li><a href="best-practice-security.html">安全最佳作法</a>
</li>
<li><a href="best-practice-performance.html">效能最佳作法</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<ul id="resources-menu" class="menu">
<li><a href="../resources/glossary.html">資源</a>
<ul>
<li><a href="../resources/glossary.html">名詞解釋</a>
</li>
<li><a href="../resources/middleware.html">中介軟體</a>
</li>
<li><a href="../resources/community.html">社群</a>
</li>
<li><a href="../resources/books-blogs.html">書籍與部落格</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</header>
<div id="overlay"></div>
<div id="i18n-notice-box" class="doc-box doc-warn">
<p><p>這個翻譯<a href="http://strongloop.com/">StrongLoop / IBM</a>提供.</p>
相對於英文版說明文件，本文件可能已不合時宜。如需最新的更新，請參閱<a href="../../index.html">英文版說明文件</a>。
</p>
<div id="close-i18n-notice-box" title="Close">✖</div>
</div>
<div id="page-doc" markdown="1">
<h1 id="正式作業最佳作法效能和可靠性">正式作業最佳作法：效能和可靠性</h1>
<h2 id="概觀">概觀</h2>
<p>本文討論部署至正式作業之 Express 應用程式的效能與可靠性最佳作法。</p>
<p>顯然地，這個主題屬於 “devops” 領域，涵蓋了傳統開發和作業兩者。因此，資訊分為兩大部分：</p>
<ul>
<li><a href="#code">在程式碼中的作法</a>（開發部分）。</li>
<li><a href="#env">在環境 / 設定中的作法</a>（作業部分）。</li>
</ul>
<p><a name="code"></a></p>
<h2 id="在程式碼中的作法">在程式碼中的作法</h2>
<p>以下是您可以在程式碼中執行的一些作法，藉以改良您應用程式的效能：</p>
<ul>
<li>採用 gzip 壓縮</li>
<li>不使用同步函數</li>
<li>使用中介軟體來提供靜態檔案</li>
<li>正確執行記載</li>
<li>適當處理異常狀況</li>
</ul>
<h3 id="採用-gzip-壓縮">採用 gzip 壓縮</h3>
<p>Gzip 壓縮可以大幅減少回應內文的大小，從而提高 Web 應用程式的速度。請使用 <a href="https://www.npmjs.com/package/compression">compression</a> 中介軟體，在您的 Express 應用程式中進行 gzip 壓縮。例如：</p>
<pre><code class="language-javascript" translate="no">
var compression = require('compression');
var express = require('express');
var app = express();
app.use(compression());
</code>
</pre>
<p>在正式作業中，如果網站的資料流量極高，落實執行壓縮最好的作法是在反向 Proxy 層次實作它（請參閱<a href="#proxy">使用反向 Proxy</a>）。在該情況下，就不需使用壓縮中介軟體。如需在 Nginx 中啟用 gzip 壓縮的詳細資料，請參閱 Nginx 說明文件中的 <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">ngx_http_gzip_module 模組</a>。</p>
<h3 id="不使用同步函數">不使用同步函數</h3>
<p>同步函數和方法直到傳回前，會阻礙執行程序的進行。單次呼叫同步函數，可能在數微秒或毫秒傳回，不過，在高資料流量的網站中，這些呼叫往往會累加，並降低應用程式效能。請避免在正式作業中使用它們。</p>
<p>雖然 Node 和許多模組會提供其函數的同步與非同步版本，在正式作業中，請一律使用非同步版本。唯一有理由使用同步函數的時機是在最初啟動之時。</p>
<p>如果您使用 Node.js 4.0+ 或 io.js 2.1.0+，每當您的應用程式使用同步 API 時，您可以使用 <code>--trace-sync-io</code> 指令行旗標，來列印警告和堆疊追蹤。當然，在正式作業中您其實不會想使用此旗標，但這可確保您的程式碼可準備用於正式作業中。如需相關資訊，請參閱 <a href="https://nodejs.org/en/blog/weekly-updates/weekly-update.2015-05-22/#2-1-0">io.js 2.1.0 每週更新</a>。</p>
<h3 id="使用中介軟體來提供靜態檔案">使用中介軟體來提供靜態檔案</h3>
<p>在開發中，您可以使用 <a href="../4x/api.html#res.sendFile">res.sendFile()</a> 來提供靜態檔案。但是在正式作業中卻不能這樣做，因為此函數得讀取檔案系統，才能取得每一個檔案要求，如此會遇到明顯的延遲，並影響應用程式的整體效能。請注意，<code>res.sendFile()</code> <em>並非</em>透過更具效率的 <a href="http://linux.die.net/man/2/sendfile">sendfile</a> 系統呼叫來實作。</p>
<p>請改用 <a href="https://www.npmjs.com/package/serve-static">serve-static</a> 中介軟體（或同等項目），此中介軟體能有效提供 Express 應用程式的檔案。</p>
<p>甚至更好的作法是使用反向 Proxy 來提供靜態檔案；如需相關資訊，請參閱<a href="#proxy">使用反向 Proxy</a>。</p>
<h3 id="正確執行記載">正確執行記載</h3>
<p>一般而言，從您的應用程式進行記載的原因有二：為了除錯，以及為了記載應用程式活動（其實就是除錯之外的每一項）。使用 <code>console.log()</code> 或 <code>console.err()</code> 將日誌訊息列印至終端機，在開發中是常見作法。但是當目的地是終端機或檔案時，<a href="https://nodejs.org/api/console.html#console_console_1">這些函數是同步的</a>，除非您將輸出引導至另一個程式，這些函數並不適用於正式作業。</p>
<h4 id="為了除錯">為了除錯</h4>
<p>如果您為了除錯而記載，則不要使用 <code>console.log()</code>，請改用 <a href="https://www.npmjs.com/package/debug">debug</a> 之類的特殊除錯模組。這個模組可讓您使用 DEBUG 環境變數，來控制哪些除錯訊息（若有的話）要送往 <code>console.err()</code>。為了讓應用程式完全維持非同步，您仍得將 <code>console.err()</code> 引導至另一個程式。但之後在正式作業中，實際上您並不會進行除錯，不是嗎？</p>
<h4 id="為了應用程式活動">為了應用程式活動</h4>
<p>如果您要記載應用程式活動（例如，追蹤資料流量或 API 呼叫），則不要使用 <code>console.log()</code>，請改用 <a href="https://www.npmjs.com/package/winston">Winston</a> 或
<a href="https://www.npmjs.com/package/bunyan">Bunyan</a> 之類的記載程式庫。如需這兩種程式庫的詳細比較，請參閱 StrongLoop 部落格文章 <a href="https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/">Comparing Winston and Bunyan Node.js Logging</a>。</p>
<p><a name="exceptions"></a></p>
<h3 id="適當處理異常狀況">適當處理異常狀況</h3>
<p>Node 應用程式一旦遇到未捕捉到的異常狀況，就會當機。如果不處理異常狀況，並採取適當的動作，您的 Express 應用程式會當機並且離線。如果您遵循下方<a href="#restart">確定您的應用程式自動重新啟動</a>中的建議，應用程式就能從當機回復。幸好 Express 應用程式的啟動時間通常很短。然而，您會希望一開始就避免當機，如果要這樣做，您需要適當處理異常狀況。</p>
<p>為了確保您能處理所有的異常狀況，請使用下列技術：</p>
<ul>
<li><a href="#try-catch">使用 try-catch</a></li>
<li><a href="#promises">使用 promise</a></li>
</ul>
<p>在分別討論這兩個主題之前，您對 Node/Express 錯誤處理方式應有基本的瞭解：使用「錯誤優先回呼」，並將錯誤傳播至中介軟體。Node 從非同步函數傳回錯誤時，會採用「錯誤優先回呼」慣例，其中，回呼函數的第一個參數是錯誤物件，接著是後續參數中的結果資料。如果要指出無錯誤，會傳遞 null 作為第一個參數。回呼函數必須同樣遵循「錯誤優先回呼」慣例，才能實際處理錯誤。在 Express 中，最佳作法是使用 next() 函數，透過中介軟體鏈來傳播錯誤。</p>
<p>如需進一步瞭解錯誤處理的基本概念，請參閱：</p>
<ul>
<li><a href="https://www.joyent.com/developers/node/design/errors">Error Handling in Node.js</a></li>
<li><a href="https://strongloop.com/strongblog/robust-node-applications-error-handling/">Building Robust Node Applications: Error Handling</a> (StrongLoop blog)</li>
</ul>
<h4 id="禁止事項">禁止事項</h4>
<p>有一件事<em>不能</em>做，就是接聽 <code>uncaughtException</code> 事件，此事件是在回歸事件迴圈期間不斷引發異常狀況時產生的。新增 <code>uncaughtException</code> 的事件接聽器，會使遇到異常狀況的程序變更其預設行為；儘管發生異常狀況，該程序會繼續執行。阻止應用程式當機，似乎是個好辦法，但是在未捕捉到異常狀況之後，又繼續執行應用程式，卻是危險作法而不建議這麼做，因為程序的狀態會變得不可靠且無法預測。</p>
<p>此外，使用 <code>uncaughtException</code> 被公認為<a href="https://nodejs.org/api/process.html#process_event_uncaughtexception">拙劣作法</a>，這裡有一份<a href="https://github.com/nodejs/node-v0.x-archive/issues/2582">提案</a>，指出如何將它從核心移除。因此，接聽 <code>uncaughtException</code> 並不可取。這是我們建議採取多重程序和監督程式等事項的原因：當機再重新啟動，通常是從錯誤回復最可靠的作法。</p>
<p>我們也不建議使用 <a href="https://nodejs.org/api/domain.html">domains</a>。它通常不能解決問題，並且是個已淘汰的模組。</p>
<p><a name="try-catch"></a></p>
<h4 id="使用-try-catch">使用 try-catch</h4>
<p>try-catch 是一種 JavaScript 語言建構，可用來捕捉同步程式碼中的異常狀況。例如，如以下所示，利用 try-catch 來處理 JSON 剖析錯誤。</p>
<p>使用 <a href="http://jshint.com/">JSHint</a> 或 <a href="http://www.jslint.com/">JSLint</a> 之類的工具，有助您尋找隱含的異常狀況，例如<a href="http://www.jshint.com/docs/options/#undef">參照未定義變數中的錯誤</a>。</p>
<p>下列範例顯示如何使用 try-catch 來處理潛在的程序當機異常狀況。此中介軟體函數接受名稱是 “params” 的查詢欄位參數，它是一個 JSON 物件。</p>
<pre><code class="language-javascript" translate="no">
app.get('/search', function (req, res) {
  // Simulating async operation
  setImmediate(function () {
    var jsonStr = req.query.params;
    try {
      var jsonObj = JSON.parse(jsonStr);
      res.send('Success');
    } catch (e) {
      res.status(400).send('Invalid JSON string');
    }
  });
});
</code>
</pre>
<p>不過，try-catch 只適用於同步程式碼。由於 Node 平台主要是非同步（尤其是在正式作業環境），try-catch 不會捕捉大量的異常狀況。</p>
<p><a name="promises"></a></p>
<h4 id="使用-promise">使用 promise</h4>
<p>只要非同步程式碼區塊使用 <code>then()</code>，promise 就會處理其中的任何異常狀況（包括明確和隱含）。只需在 promise 鏈尾端新增 <code>.catch(next)</code> 即可。例如：</p>
<pre><code class="language-javascript" translate="no">
app.get('/', function (req, res, next) {
  // do some sync stuff
  queryDb()
    .then(function (data) {
      // handle data
      return makeCsv(data)
    })
    .then(function (csv) {
      // handle csv
    })
    .catch(next);
});

app.use(function (err, req, res, next) {
  // handle error
});
</code>
</pre>
<p>現在，所有非同步與同步錯誤都會傳播到錯誤中介軟體。</p>
<p>不過，請注意下列兩項警告：</p>
<ol>
<li>您所有的非同步程式碼都必須傳回 promise（不包括發射程式）。如果特定程式庫沒有傳回 promise，請使用 <a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html">Bluebird.promisifyAll()</a> 等之類的 helper 函數來轉換基本物件。</li>
<li>事件發射程式（例如：串流）仍可能造成未捕捉到的異常狀況。因此，請確定錯誤事件的處理適當；例如：</li>
</ol>
<pre><code class="language-javascript" translate="no">
app.get('/', wrap(async (req, res, next) =&gt; {
  let company = await getCompanyById(req.query.id)
  let stream = getLogoStreamById(company.id)
  stream.on('error', next).pipe(res)
}))
</code>
</pre>
<p>如需使用 promise 來處理錯誤的相關資訊，請參閱：</p>
<ul>
<li><a href="https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/">Asynchronous Error Handling in Express with Promises, Generators and ES7</a></li>
<li><a href="https://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/">Promises in Node.js with Q – An Alternative to Callbacks</a></li>
</ul>
<p><a name="env"></a></p>
<h2 id="在環境--設定中的作法">在環境 / 設定中的作法</h2>
<p>以下是您可以在系統環境中執行的一些作法，藉以改良您應用程式的效能：</p>
<ul>
<li>將 NODE_ENV 設為 “production”</li>
<li>確定您的應用程式自動重新啟動</li>
<li>在叢集中執行應用程式</li>
<li>快取要求結果</li>
<li>使用負載平衡器</li>
<li>使用反向 Proxy</li>
</ul>
<h3 id="將-node_env-設為-production">將 NODE_ENV 設為 “production”</h3>
<p>NODE_ENV 環境變數用來指定應用程式的執行環境（通常是開發或正式作業）。若要改良效能，其中一個最簡單的作法是將 NODE_ENV 設為 “production”。</p>
<p>將 NODE_ENV 設為 “production”，可讓 Express：</p>
<ul>
<li>快取視圖範本。</li>
<li>快取從 CSS 延伸項目產生的 CSS 檔案。</li>
<li>產生簡略的錯誤訊息。</li>
</ul>
<p><a href="http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/">測試指出</a>單單這樣做，就能提高 3 倍的應用程式效能！</p>
<p>如果您需要撰寫環境特定的程式碼，您可以使用 <code>process.env.NODE_ENV</code> 來檢查 NODE_ENV 的值。請注意，檢查任何環境變數的值都會影響效能，因此請慎行。</p>
<p>在開發中，您通常是在互動式 Shell 中設定環境變數，例如，使用 <code>export</code> 或您的 <code>.bash_profile</code> 檔。但是在正式作業伺服器中，通常您應該不會這樣做；反而是使用您作業系統的 init 系統（systemd 或 Upstart）。下一節詳述一般性的 init 系統用法，但由於設定 NODE_ENV 對於效能來說很重要（而且輕而易舉），這裡仍特別強調。</p>
<p>採用 Upstart 時，請在您的工作檔中使用 <code>env</code> 關鍵字。例如：</p>
<pre><code class="language-sh" translate="no">
# /etc/init/env.conf
 env NODE_ENV=production
</code>
</pre>
<p>如需相關資訊，請參閱 <a href="http://upstart.ubuntu.com/cookbook/#environment-variables">Upstart Intro, Cookbook and Best Practices</a>。</p>
<p>採用 systemd 時，請在單位檔案中使用 <code>Environment</code> 指引。例如：</p>
<pre><code class="language-sh" translate="no">
# /etc/systemd/system/myservice.service
Environment=NODE_ENV=production
</code>
</pre>
<p>如需相關資訊，請參閱 <a href="https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html">Using Environment Variables In systemd Units</a>。</p>
<p>如果您使用 StrongLoop Process Manager，您也可以<a href="https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-Setenvironmentvariables">在將 StrongLoop PM 安裝成服務時，設定環境變數</a>。</p>
<h3 id="確定您的應用程式自動重新啟動">確定您的應用程式自動重新啟動</h3>
<p>在正式作業中，您始終不希望您的應用程式離線。也就是說，不論是應用程式當機，或是伺服器本身當機，您都需要確保它會重新啟動。儘管最好這些事件都不要發生，您仍必須務實看待這兩種可能的情況，其作法如下：</p>
<ul>
<li>當應用程式（和 Node）當機時，使用程序管理程式重新啟動它。</li>
<li>當作業系統當機時，使用您作業系統提供的 init 系統，來重新啟動程序管理程式。也有可能可以使用 init 系統，而不使用程序管理程式。</li>
</ul>
<p>Node 應用程式一旦遇到未捕捉到的異常狀況，就會當機。首要之務是確定您的應用程式已妥善測試，且已處理所有的異常狀況（請參閱<a href="#exceptions">適當處理異常狀況</a>，以取得詳細資料）。但是萬全的作法是落實執行機制，以確保萬一您的應用程式當機，它會自動重新啟動。</p>
<h4 id="使用程序管理程式">使用程序管理程式</h4>
<p>在開發中，只需從指令行使用 <code>node server.js</code> 或類似指令，就會啟動應用程式。但在正式作業中這樣做，卻會成為禍因。如果應用程式當機，就會離線直到您重新啟動它為止。為了確保應用程式會在當機時重新啟動，請使用程序管理程式。程序管理程式是一個應用程式的「儲存器」，有助於部署、提供高可用性，並可讓您在執行時期管理應用程式。</p>
<p>除了在應用程式當機時重新啟動它，程序管理程式還可讓您：</p>
<ul>
<li>洞察執行時期效能和資源的耗用情況。</li>
<li>動態修改設定，以改良效能。</li>
<li>控制叢集作業（StrongLoop PM 和 pm2）。</li>
</ul>
<p>最普及的 Node 程序管理程式如下：</p>
<ul>
<li><a href="http://strong-pm.io/">StrongLoop Process Manager</a></li>
<li><a href="https://github.com/Unitech/pm2">PM2</a></li>
<li><a href="https://www.npmjs.com/package/forever">Forever</a></li>
</ul>
<p>有關這三種程序管理程式的特性比較，請參閱 <a href="http://strong-pm.io/compare/">http://strong-pm.io/compare/</a>。如需這三種的詳細介紹，請參閱 <a href="pm.html">Express 應用程式的程序管理程式</a>。</p>
<p>即使您的應用程式不時發生當機，這些程序管理程式不論哪一個都足以讓您的應用程式維持作用中。</p>
<p>不過，StrongLoop PM 有許多特性明確以正式作業部署為目標。您可以使用它和相關的 StrongLoop 工具來：</p>
<ul>
<li>在本端建置和包裝您的應用程式，然後安全地部署到正式作業系統。</li>
<li>在應用程式當機時（不論任何原因），自動重新啟動。</li>
<li>遠端管理叢集。</li>
<li>檢視 CPU 設定檔和資料堆 Snapshot，使效能達到最佳，並診斷記憶體洩漏情況。</li>
<li>檢視您應用程式的效能度量。</li>
<li>藉由 Nginx 負載平衡器的整合控制，輕鬆調整至多部主機。</li>
</ul>
<p>如同以下說明，當您使用 init 系統將 StrongLoop PM 安裝成作業系統服務時，它會自動隨系統一起重新啟動。因此，它會讓您的應用程式程序和叢集永遠維持作用中。</p>
<h4 id="使用-init-系統">使用 init 系統</h4>
<p>接下來的可靠性層級是確保您的應用程式會隨伺服器一起重新啟動。系統仍可能因各種不同的原因而關閉。為了確保您的應用程式會在伺服器當機時重新啟動，請使用您作業系統內建的 init 系統。現今兩個通行的主要 init 系統是 <a href="https://wiki.debian.org/systemd">systemd</a> 和 <a href="http://upstart.ubuntu.com/">Upstart</a>。</p>
<p>init 系統若要與 Express 應用程式搭配使用，其作法有二：</p>
<ul>
<li>在程序管理程式中執行應用程式，並利用 init 系統將程序管理程式安裝成服務。當應用程式當機時，程序管理程式會重新啟動應用程式，且 init 系統會在作業系統重新啟動時，重新啟動程序管理程式。這是建議的作法。</li>
<li>直接使用 init 系統來執行應用程式（和 Node）。這樣做比較簡單，但卻少了使用程序管理程式時的其他好處。</li>
</ul>
<h5 id="systemd">Systemd</h5>
<p>Systemd 是一個 Linux 系統和服務管理程式。大部分主要的 Linux 發行套件已採用 systemd 作為其預設 init 系統。</p>
<p>systemd 服務配置檔稱為<em>單位檔案</em>，其副名結尾是 .service。以下是範例單位檔案，用來直接管理 Node 應用程式（請以您的系統和應用程式值取代粗體字）：</p>
<pre><code class="language-sh" translate="no">
[Unit]
Description=Awesome Express App

[Service]
Type=simple
ExecStart=/usr/local/bin/node /projects/myapp/index.js
WorkingDirectory=/projects/myapp

User=nobody
Group=nogroup

# Environment variables:
Environment=NODE_ENV=production

# Allow many incoming connections
LimitNOFILE=infinity

# Allow core dumps for debugging
LimitCORE=infinity

StandardInput=null
StandardOutput=syslog
StandardError=syslog
Restart=always

[Install]
WantedBy=multi-user.target
</code>
</pre>
<p>如需 systemd 的相關資訊，請參閱 <a href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html">systemd 參照（線上指令說明）</a>。</p>
<h5 id="將-strongloop-pm-當成-systemd-服務">將 StrongLoop PM 當成 systemd 服務</h5>
<p>將 StrongLoop Process Manager 安裝成 systemd 服務很簡單。完成之後，當伺服器重新啟動時，就會自動重新啟動 StrongLoop PM，之後它就會重新啟動其所管理的所有應用程式。</p>
<p>將 StrongLoop PM 安裝成 systemd 服務：</p>
<pre><code class="language-sh" translate="no">
$ sudo sl-pm-install --systemd
</code>
</pre>
<p>然後使用下列指令來啟動服務：</p>
<pre><code class="language-sh" translate="no">
$ sudo /usr/bin/systemctl start strong-pm
</code>
</pre>
<p>如需相關資訊，請參閱 <a href="https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-RHEL7+,Ubuntu15.04or15.10">Setting up a production host（StrongLoop 說明文件）</a>。</p>
<h5 id="upstart">Upstart</h5>
<p>Upstart 是一個可在許多 Linux 發行套件中使用的系統工具，它會在系統啟動期間啟動作業和服務、在關機期間停止它們，並且監督它們。您可以將 Express 應用程式或程序管理程式配置成服務，之後 Express 應用程式或程序管理程式一旦發生當機，Upstart 就會自動重新啟動它。</p>
<p>Upstart 服務定義在工作配置檔（亦稱為 “job”）中，其副名結尾是 <code>.conf</code>。下列範例顯示如何為名稱是 “myapp” 的應用程式，建立一項名稱是 “myapp” 的工作，且其主要檔案位於 <code>/projects/myapp/index.js</code>。</p>
<p>在 <code>/etc/init/</code> 建立名稱是 <code>myapp.conf</code> 的檔案，且其內容如下（請以您系統和應用程式的值取代粗體字）：</p>
<pre><code class="language-sh" translate="no">
# When to start the process
start on runlevel [2345]

# When to stop the process
stop on runlevel [016]

# Increase file descriptor limit to be able to handle more requests
limit nofile 50000 50000

# Use production mode
env NODE_ENV=production

# Run as www-data
setuid www-data
setgid www-data

# Run from inside the app dir
chdir /projects/myapp

# The process to start
exec /usr/local/bin/node /projects/myapp/index.js

# Restart the process if it is down
respawn

# Limit restart attempt to 10 times within 10 seconds
respawn limit 10 10
</code>
</pre>
<p>附註：這個 Script 需要 Upstart 1.4 或更新版本，且 Ubuntu 12.04-14.10 支援該 Upstart 版本。</p>
<p>由於工作是配置成在系統啟動時執行，您的應用程式會隨作業系統一起啟動，並在應用程式當機或系統關閉時自動重新啟動。</p>
<p>除了自動重新啟動應用程式，Upstart 可讓您使用下列指令：</p>
<ul>
<li><code>start myapp</code> – 啟動應用程式</li>
<li><code>restart myapp</code> – 重新啟動應用程式</li>
<li><code>stop myapp</code> – 停止應用程式。</li>
</ul>
<p>如需 Upstart 的相關資訊，請參閱 <a href="http://upstart.ubuntu.com/cookbook">Upstart Intro, Cookbook and Best Practises</a>。</p>
<h5 id="將-strongloop-pm-當成-upstart-服務">將 StrongLoop PM 當成 Upstart 服務</h5>
<p>將 StrongLoop Process Manager 安裝成 Upstart 服務很簡單。完成之後，當伺服器重新啟動時，就會自動重新啟動 StrongLoop PM，之後它就會重新啟動其所管理的所有應用程式。</p>
<p>將 StrongLoop PM 安裝成 Upstart 1.4 服務：</p>
<pre><code class="language-sh" translate="no">
$ sudo sl-pm-install
</code>
</pre>
<p>然後使用下列指令來執行服務：</p>
<pre><code class="language-sh" translate="no">
$ sudo /sbin/initctl start strong-pm
</code>
</pre>
<p>附註：在不支援 Upstart 1.4 的系統上，指令略有不同。如需相關資訊，請參閱 <a href="https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-RHELLinux5and6,Ubuntu10.04-.10,11.04-.10">Setting up a production host（StrongLoop 說明文件）</a>。</p>
<h3 id="在叢集中執行應用程式">在叢集中執行應用程式</h3>
<p>在多核心系統中，您可以啟動程序叢集，多次提高 Node 應用程式的效能。叢集會執行該應用程式的多個實例，理論上，每一個 CPU 核心上各有一個實例，因此負載和作業會分散在這些實例之間。</p>

<p>重要事項：由於應用程式實例是以個別程序形式執行，因此不會共用相同的記憶體空間。也就是說，物件位於每一個應用程式實例本端。因此，您無法在應用程式碼中維護狀態。不過，您可以利用 <a href="http://redis.io/">Redis</a> 等之類的記憶體內資料儲存庫，來儲存階段作業的相關資料和狀態。不論叢集是由多個程序或多部實體伺服器組成，這項警告其實適用於所有的水平調整形式。</p>
<p>在叢集化的應用程式中，工作者程序可個別當機，而不會影響其餘的程序。除了效能優點，執行應用程式程序叢集的另一個原因是，可將失效隔離。只要有工作者程序當機，一律要確定會記載事件，並利用 cluster.fork() 來衍生新程序。</p>
<h4 id="使用-node-的叢集模組">使用 Node 的叢集模組</h4>
<p>利用 Node 的<a href="https://nodejs.org/docs/latest/api/cluster.html">叢集模組</a>，即可達成叢集作業。這可讓主要程序衍生工作者程序，並將送入的連線分散在這些工作者之間。不過，與其直接使用這個模組，更好的作法是使用其中提供的一個工具，自動為您執行叢集作業；
例如 <a href="https://www.npmjs.com/package/node-pm">node-pm</a> 或 <a href="https://www.npmjs.com/package/cluster-service">cluster-service</a>。</p>
<h4 id="使用-strongloop-pm">使用 StrongLoop PM</h4>
<p>如果您將應用程式部署至 StrongLoop Process Manager (PM)，您可以善用叢集作業，且<em>不需</em>修改應用程式碼。</p>
<p>當 StrongLoop Process Manager (PM) 執行應用程式時，它會自動在叢集中執行它，且該叢集中的工作者數目等於系統上的 CPU 核心數。您可以使用 slc 指令行工具，直接手動變更工作者程序數目，而不需停止應用程式。</p>
<p>舉例來說，假設您將應用程式部署至 prod.foo.com，且 StrongLoop PM 是在埠 8701（預設值）接聽，請使用 slc 將叢集大小設為 8：</p>
<pre><code class="language-sh" translate="no">
$ slc ctl -C http://prod.foo.com:8701 set-size my-app 8
</code>
</pre>
<p>如需利用 StrongLoop PM 執行叢集作業的相關資訊，請參閱 StrongLoop 說明文件中的<a href="https://docs.strongloop.com/display/SLC/Clustering">叢集作業</a>。</p>
<h3 id="快取要求結果">快取要求結果</h3>
<p>在正式作業中改良效能的另一項策略是快取要求的結果，這樣您的應用程式就不會重複執行作業而反覆處理相同的要求。</p>
<p>使用 <a href="https://www.varnish-cache.org/">Varnish</a> 或 <a href="https://www.nginx.com/resources/wiki/start/topics/examples/reverseproxycachingexample/">Nginx</a>（另請參閱 <a href="https://serversforhackers.com/nginx-caching/">Nginx 快取</a>）等之類的快取伺服器，可大幅改良您應用程式的速度與效能。</p>
<h3 id="使用負載平衡器">使用負載平衡器</h3>
<p>不論如何將應用程式最佳化，單一實例所能處理的負載量與資料流量有限。調整應用程式的其中一個作法是執行其多個實例，並透過負載平衡器來分散資料流量。設定負載平衡器可改良您應用程式的效能和速度，且透過其單一實例，使該應用程式得以多次調整。</p>
<p>負載平衡器通常是一個反向 Proxy，負責協調與多個應用程式實例和伺服器之間的資料流量。利用 <a href="http://nginx.org/en/docs/http/load_balancing.html">Nginx</a> 或 <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts">HAProxy</a>，就能輕鬆設定您應用程式的負載平衡器。</p>
<p>如果進行負載平衡，您可能得確定與特定階段作業 ID 相關聯的要求，會連接至發出該要求的程序。這就是所謂的<em>階段作業親緣性</em>或<em>組合階段作業</em>，如果要解決此情況，可按照上述建議，使用 Redis 等之類的資料儲存庫來儲存階段作業資料（視您的應用程式而定）。相關討論請參閱<a href="http://socket.io/docs/using-multiple-nodes/">使用多個節點</a>。</p>
<h4 id="strongloop-pm-與-nginx-負載平衡器搭配使用">StrongLoop PM 與 Nginx 負載平衡器搭配使用</h4>
<p><a href="http://strong-pm.io/">StrongLoop Process Manager</a> 整合了 Nginx Controller，因此配置多主機正式作業環境配置更簡單。如需相關資訊，請參閱 <a href="https://docs.strongloop.com/display/SLC/Scaling+to+multiple+servers">Scaling to multiple servers</a>（StrongLoop 說明文件）。
<a name="proxy"></a></p>
<h3 id="使用反向-proxy">使用反向 Proxy</h3>
<p>反向 Proxy 位於 Web 應用程式前面，除了將要求引導至應用程式，也會對要求執行支援的作業。除此之外，它還可以處理錯誤頁面、壓縮、快取、提供的檔案，以及負載平衡。</p>
<p>將不需要瞭解應用程式狀態的作業移交給反向 Proxy，使 Express 更有餘裕執行特殊的應用程式作業。基於此因，在正式作業中，建議讓 Express 在 <a href="https://www.nginx.com/">Nginx</a> 或 <a href="http://www.haproxy.org/">HAProxy</a> 等之類的反向 Proxy 背後執行。</p>
</div>
</section>

<noscript>
    <iframe src="http://www.googletagmanager.com/ns.html?id=GTM-5XL76H" height="0" width="0" style="display: none; visibility: hidden;"></iframe>
</noscript>
<script type="c86e6a4bbf3b019473edb0ce-text/javascript">
(function(w, d, s, l, i) {
    w[l] = w[l] || [];
    w[l].push({
        'gtm.start': new Date().getTime(),
        event: 'gtm.js'
    });
    var f = d.getElementsByTagName(s)[0],
        j = d.createElement(s),
        dl = l != 'dataLayer' ? '&l=' + l : '';
    j.async = true;
    j.src =
        '../../../www.googletagmanager.com/gtm5445.js?id=' + i + dl;
    f.parentNode.insertBefore(j, f);
})(window, document, 'script', 'dataLayer', 'GTM-5XL76H');
</script>
<a id="top" href="#"><img src="../../images/arrow.png"></a>
<footer>
<div id="footer-content">
<div id="github">
<iframe src="http://ghbtns.com/github-btn.html?user=expressjs&amp;repo=express&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
</div>
<div id="sponsor"><a href="https://github.com/expressjs/express">Express</a>是Node.js的基金會的一個項目。</div>
<div id="fork"><a href="https://github.com/expressjs/expressjs.com">GitHub 上的網站分支</a>。
</div>
<div>Copyright &copy; StrongLoop, Inc. 與其他 expressjs.com 貢獻者。</div>
</div>
<div id="license">
<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/us/"><img alt="創用 CC 授權條款" style="border-width:0" src="../../../i.creativecommons.org/l/by-sa/3.0/us/80x15.png" /></a> 本著作係採用<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/us/">創用 CC 姓名標示-相同方式分享 3.0 美國 授權條款</a>授權.
</div>
</footer>
<script type="c86e6a4bbf3b019473edb0ce-text/javascript" src="../../../cdn.jsdelivr.net/npm/docsearch.js%402/dist/cdn/docsearch.min.js" onload="docsearch({
  apiKey: '7164e33055faa6ecddefd9e08fc59f5d',
  indexName: 'expressjs',
  inputSelector: '#q',
  algoliaOptions: { 'facetFilters': ['lang:zh-tw'] }
})" async></script>
<script src="../../../ajax.cloudflare.com/cdn-cgi/scripts/a2bd7673/cloudflare-static/rocket-loader.min.js" data-cf-settings="c86e6a4bbf3b019473edb0ce-|49" defer=""></script></body>

<!-- Mirrored from expressjs.com/zh-tw/advanced/best-practice-performance.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 10 Jul 2019 00:23:50 GMT -->
</html>
