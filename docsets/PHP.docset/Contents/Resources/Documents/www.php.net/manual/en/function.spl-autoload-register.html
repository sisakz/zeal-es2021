<html><!-- Mirrored from www.php.net/manual/en/function.spl-autoload-register.php by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 11 Sep 2021 06:40:08 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->


  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>spl_autoload_register</title>

 <link rel="shortcut icon" href="../../favicon.ico">
 <link rel="search" type="application/opensearchdescription+xml" href="http://php.net/phpnetimprovedsearch.src" title="Add PHP.net search">
 <link rel="alternate" type="application/atom+xml" href="https://www.php.net/releases/feed.php" title="PHP Release feed">
 <link rel="alternate" type="application/atom+xml" href="https://www.php.net/feed.atom" title="PHP: Hypertext Preprocessor">

 <link rel="canonical" href="function.spl-autoload-register.html">
 <link rel="shorturl" href="https://www.php.net/spl-autoload-register">
 <link rel="alternate" href="https://www.php.net/spl-autoload-register" hreflang="x-default">

 <link rel="contents" href="index-2.html">
 <link rel="index" href="ref.spl.html">
 <link rel="prev" href="function.spl-autoload-functions.html">
 <link rel="next" href="function.spl-autoload-unregister.html">

 <link rel="alternate" href="function.spl-autoload-register.html" hreflang="en">
 <link rel="alternate" href="https://www.php.net/manual/pt_BR/function.spl-autoload-register.php" hreflang="pt_BR">
 <link rel="alternate" href="https://www.php.net/manual/zh/function.spl-autoload-register.php" hreflang="zh">
 <link rel="alternate" href="https://www.php.net/manual/fr/function.spl-autoload-register.php" hreflang="fr">
 <link rel="alternate" href="https://www.php.net/manual/de/function.spl-autoload-register.php" hreflang="de">
 <link rel="alternate" href="https://www.php.net/manual/ja/function.spl-autoload-register.php" hreflang="ja">
 <link rel="alternate" href="https://www.php.net/manual/ro/function.spl-autoload-register.php" hreflang="ro">
 <link rel="alternate" href="https://www.php.net/manual/ru/function.spl-autoload-register.php" hreflang="ru">
 <link rel="alternate" href="https://www.php.net/manual/es/function.spl-autoload-register.php" hreflang="es">
 <link rel="alternate" href="https://www.php.net/manual/tr/function.spl-autoload-register.php" hreflang="tr">

<link rel="stylesheet" type="text/css" href="../../cached0aba.css?t=1539771603&amp;f=/fonts/Fira/fira.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached2ecf.css?t=1539765004&amp;f=/fonts/Font-Awesome/css/fontello.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cachedba57.css?t=1606338002&amp;f=/styles/theme-base.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached3afa.css?t=1627831203&amp;f=/styles/theme-medium.css" media="screen">

 <!--[if lte IE 7]>
 <link rel="stylesheet" type="text/css" href="https://www.php.net/styles/workarounds.ie7.css" media="screen">
 <![endif]-->

 <!--[if lte IE 8]>
 <script>
  window.brokenIE = true;
 </script>
 <![endif]-->

 <!--[if lte IE 9]>
 <link rel="stylesheet" type="text/css" href="https://www.php.net/styles/workarounds.ie9.css" media="screen">
 <![endif]-->

 <!--[if IE]>
 <script src="https://www.php.net/js/ext/html5.js"></script>
 <![endif]-->

 <base>


</head>
<body class="docs " style="">


<div class="headsup"><a href="https://www.php.net/conferences/index.php#id2021-09-08-1">Longhorn PHP 2021</a></div>
<nav id="trick"><div><dl>
<dt><a href="getting-started.html">Getting Started</a></dt>
	<dd><a href="introduction.html">Introduction</a></dd>
	<dd><a href="tutorial.html">A simple tutorial</a></dd>
<dt><a href="langref.html">Language Reference</a></dt>
	<dd><a href="language.basic-syntax.html">Basic syntax</a></dd>
	<dd><a href="language.types.html">Types</a></dd>
	<dd><a href="language.variables.html">Variables</a></dd>
	<dd><a href="language.constants.html">Constants</a></dd>
	<dd><a href="language.expressions.html">Expressions</a></dd>
	<dd><a href="language.operators.html">Operators</a></dd>
	<dd><a href="language.control-structures.html">Control Structures</a></dd>
	<dd><a href="language.functions.html">Functions</a></dd>
	<dd><a href="language.oop5.html">Classes and Objects</a></dd>
	<dd><a href="language.namespaces.html">Namespaces</a></dd>
	<dd><a href="language.errors.html">Errors</a></dd>
	<dd><a href="language.exceptions.html">Exceptions</a></dd>
	<dd><a href="language.generators.html">Generators</a></dd>
	<dd><a href="language.attributes.html">Attributes</a></dd>
	<dd><a href="language.references.html">References Explained</a></dd>
	<dd><a href="reserved.variables.html">Predefined Variables</a></dd>
	<dd><a href="reserved.exceptions.html">Predefined Exceptions</a></dd>
	<dd><a href="reserved.interfaces.html">Predefined Interfaces and Classes</a></dd>
	<dd><a href="context.html">Context options and parameters</a></dd>
	<dd><a href="wrappers.html">Supported Protocols and Wrappers</a></dd>
</dl>
<dl>
<dt><a href="security.html">Security</a></dt>
	<dd><a href="security.intro.html">Introduction</a></dd>
	<dd><a href="security.general.html">General considerations</a></dd>
	<dd><a href="security.cgi-bin.html">Installed as CGI binary</a></dd>
	<dd><a href="security.apache.html">Installed as an Apache module</a></dd>
	<dd><a href="security.sessions.html">Session Security</a></dd>
	<dd><a href="security.filesystem.html">Filesystem Security</a></dd>
	<dd><a href="security.database.html">Database Security</a></dd>
	<dd><a href="security.errors.html">Error Reporting</a></dd>
	<dd><a href="security.variables.html">User Submitted Data</a></dd>
	<dd><a href="security.hiding.html">Hiding PHP</a></dd>
	<dd><a href="security.current.html">Keeping Current</a></dd>
<dt><a href="features.html">Features</a></dt>
	<dd><a href="features.http-auth.html">HTTP authentication with PHP</a></dd>
	<dd><a href="features.cookies.html">Cookies</a></dd>
	<dd><a href="features.sessions.html">Sessions</a></dd>
	<dd><a href="features.xforms.html">Dealing with XForms</a></dd>
	<dd><a href="features.file-upload.html">Handling file uploads</a></dd>
	<dd><a href="features.remote-files.html">Using remote files</a></dd>
	<dd><a href="features.connection-handling.html">Connection handling</a></dd>
	<dd><a href="features.persistent-connections.html">Persistent Database Connections</a></dd>
	<dd><a href="features.commandline.html">Command line usage</a></dd>
	<dd><a href="features.gc.html">Garbage Collection</a></dd>
	<dd><a href="features.dtrace.html">DTrace Dynamic Tracing</a></dd>
</dl>
<dl>
<dt><a href="funcref.html">Function Reference</a></dt>
	<dd><a href="refs.basic.php.html">Affecting PHP's Behaviour</a></dd>
	<dd><a href="refs.utilspec.audio.html">Audio Formats Manipulation</a></dd>
	<dd><a href="refs.remote.auth.html">Authentication Services</a></dd>
	<dd><a href="refs.utilspec.cmdline.html">Command Line Specific Extensions</a></dd>
	<dd><a href="refs.compression.html">Compression and Archive Extensions</a></dd>
	<dd><a href="refs.crypto.html">Cryptography Extensions</a></dd>
	<dd><a href="refs.database.html">Database Extensions</a></dd>
	<dd><a href="refs.calendar.html">Date and Time Related Extensions</a></dd>
	<dd><a href="refs.fileprocess.file.html">File System Related Extensions</a></dd>
	<dd><a href="refs.international.html">Human Language and Character Encoding Support</a></dd>
	<dd><a href="refs.utilspec.image.html">Image Processing and Generation</a></dd>
	<dd><a href="refs.remote.mail.html">Mail Related Extensions</a></dd>
	<dd><a href="refs.math.html">Mathematical Extensions</a></dd>
	<dd><a href="refs.utilspec.nontext.html">Non-Text MIME Output</a></dd>
	<dd><a href="refs.fileprocess.process.html">Process Control Extensions</a></dd>
	<dd><a href="refs.basic.other.html">Other Basic Extensions</a></dd>
	<dd><a href="refs.remote.other.html">Other Services</a></dd>
	<dd><a href="refs.search.html">Search Engine Extensions</a></dd>
	<dd><a href="refs.utilspec.server.html">Server Specific Extensions</a></dd>
	<dd><a href="refs.basic.session.html">Session Extensions</a></dd>
	<dd><a href="refs.basic.text.html">Text Processing</a></dd>
	<dd><a href="refs.basic.vartype.html">Variable and Type Related Extensions</a></dd>
	<dd><a href="refs.webservice.html">Web Services</a></dd>
	<dd><a href="refs.utilspec.windows.html">Windows Only Extensions</a></dd>
	<dd><a href="refs.xml.html">XML Manipulation</a></dd>
	<dd><a href="refs.ui.html">GUI Extensions</a></dd>
</dl>
<dl>
<dt>Keyboard Shortcuts</dt><dt>?</dt>
<dd>This help</dd>
<dt>j</dt>
<dd>Next menu item</dd>
<dt>k</dt>
<dd>Previous menu item</dd>
<dt>g p</dt>
<dd>Previous man page</dd>
<dt>g n</dt>
<dd>Next man page</dd>
<dt>G</dt>
<dd>Scroll to bottom</dd>
<dt>g g</dt>
<dd>Scroll to top</dd>
<dt>g h</dt>
<dd>Goto homepage</dd>
<dt>g s</dt>
<dd>Goto search<br>(current page)</dd>
<dt>/</dt>
<dd>Focus search box</dd>
</dl></div></nav>
<div id="goto">
    <div class="search">
         <div class="text"></div>
         <div class="results"><ul></ul></div>
   </div>
</div>

  <div id="breadcrumbs" class="row-fluid">
    <div id="breadcrumbs-inner">
          
              
          <ul>
            <li><a href="index-2.html">PHP Manual</a></li>      <li><a href="funcref.html">Function Reference</a></li>      <li><a href="refs.basic.other.html">Other Basic Extensions</a></li>      <li><a href="book.spl.html">SPL</a></li>      <li><a href="ref.spl.html">SPL Functions</a></li>      </ul>
    </div>
  </div>




<div id="layout" class="clearfix">
  <section id="layout-content">
  <div id="function.spl-autoload-register" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">spl_autoload_register</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.1.0, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">spl_autoload_register</span> â€” <span class="dc-title">Register given function as __autoload() implementation</span></p>

 </div>
 <div class="refsect1 description" id="refsect1-function.spl-autoload-register-description">
  <h3 class="title">Description</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>spl_autoload_register</strong></span>(<span class="methodparam"><span class="type">?</span><span class="type"><span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span><span class="type"></span></span> <code class="parameter">$callback</code><span class="initializer"> = <strong><code>null</code></strong></span></span>, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$throw</code><span class="initializer"> = <strong><code>true</code></strong></span></span>, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$prepend</code><span class="initializer"> = <strong><code>false</code></strong></span></span>): <span class="type">bool</span></div>

  <p class="para rdfs-comment">
   Register a function with the spl provided __autoload queue. If the queue
   is not yet activated it will be activated.  
  </p>
  <p class="para">
   If your code has an existing <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> function then
   this function must be explicitly registered on the __autoload queue. This
   is because <span class="function"><strong>spl_autoload_register()</strong></span> will effectively
   replace the engine cache for the <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> function
   by either <span class="function"><a href="function.spl-autoload.html" class="function">spl_autoload()</a></span> or
   <span class="function"><a href="function.spl-autoload-call.html" class="function">spl_autoload_call()</a></span>.
  </p>
  <p class="para">
   If there must be multiple autoload functions, <span class="function"><strong>spl_autoload_register()</strong></span> 
   allows for this. It effectively creates a queue of autoload functions, and
   runs through each of them in the order they are defined. By contrast, 
   <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> may only be defined once.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.spl-autoload-register-parameters">
  <h3 class="title">Parameters</h3>
  <p class="para">
   </p><dl>
    
     <dt>
<code class="parameter">callback</code></dt>

     <dd>

      <p class="para">
       The autoload function being registered.
       If <strong><code>null</code></strong>, then the default implementation of
       <span class="function"><a href="function.spl-autoload.html" class="function">spl_autoload()</a></span> will be registered.      
      </p>
      <div class="methodsynopsis dc-description">
       <span class="methodname"><span class="replaceable">callback</span></span>(<span class="methodparam"><span class="type">string</span> <code class="parameter">$class_name</code></span>): <span class="type"><span class="type void">void</span></span></div>

     </dd>

    
    
     <dt>
<code class="parameter">throw</code></dt>

     <dd>

      <p class="para">
       This parameter specifies whether
       <span class="function"><strong>spl_autoload_register()</strong></span> should throw 
       exceptions when the <code class="parameter">callback</code>
       cannot be registered.
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">prepend</code></dt>

     <dd>

      <p class="para">
       If true, <span class="function"><strong>spl_autoload_register()</strong></span> will prepend
       the autoloader on the autoload queue instead of appending it.
      </p>
     </dd>

    
   </dl>

  <p></p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.spl-autoload-register-returnvalues">
  <h3 class="title">Return Values</h3>
  <p class="para">
   Returns <strong><code>true</code></strong> on success or <strong><code>false</code></strong> on failure.
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.spl-autoload-register-changelog">
  <h3 class="title">Changelog</h3>
  <p class="para">
   </p><table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>Version</th>
       <th>Description</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>8.0.0</td>
       <td>
        <code class="parameter">callback</code> is now nullable.
       </td>
      </tr>

     </tbody>
    
   </table>

  <p></p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.spl-autoload-register-examples">
  <h3 class="title">Examples</h3>
  <p class="para">
   </p><div class="example" id="regexiterator.setflags.example.basic">
    <p><strong>Example #1 <span class="function"><strong>spl_autoload_register()</strong></span> as a replacement for an <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> function</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br><br></span><span style="color: #FF8000">//&nbsp;function&nbsp;__autoload($class)&nbsp;{<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;'classes/'&nbsp;.&nbsp;$class&nbsp;.&nbsp;'.class.php';<br>//&nbsp;}<br><br></span><span style="color: #007700">function&nbsp;</span><span style="color: #0000BB">my_autoloader</span><span style="color: #007700">(</span><span style="color: #0000BB">$class</span><span style="color: #007700">)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;</span><span style="color: #DD0000">'classes/'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$class&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">'.class.php'</span><span style="color: #007700">;<br>}<br><br></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(</span><span style="color: #DD0000">'my_autoloader'</span><span style="color: #007700">);<br><br></span><span style="color: #FF8000">//&nbsp;Or,&nbsp;using&nbsp;an&nbsp;anonymous&nbsp;function<br></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(function&nbsp;(</span><span style="color: #0000BB">$class</span><span style="color: #007700">)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;</span><span style="color: #DD0000">'classes/'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$class&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">'.class.php'</span><span style="color: #007700">;<br>});<br><br></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
   <div class="example" id="regexiterator.setmode.example.basic">
    <p><strong>Example #2 <span class="function"><strong>spl_autoload_register()</strong></span> example where the class is not loaded</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br><br></span><span style="color: #007700">namespace&nbsp;</span><span style="color: #0000BB">Foobar</span><span style="color: #007700">;<br><br>class&nbsp;</span><span style="color: #0000BB">Foo&nbsp;</span><span style="color: #007700">{<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;public&nbsp;function&nbsp;</span><span style="color: #0000BB">test</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;</span><span style="color: #DD0000">'[['</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$name&nbsp;</span><span style="color: #007700">.</span><span style="color: #DD0000">']]'</span><span style="color: #007700">;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(</span><span style="color: #0000BB">__NAMESPACE__&nbsp;</span><span style="color: #007700">.</span><span style="color: #DD0000">'\Foo::test'</span><span style="color: #007700">);<br><br>new&nbsp;</span><span style="color: #0000BB">InexistentClass</span><span style="color: #007700">;<br><br></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>The above example will output
something similar to:</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>[[Foobar\InexistentClass]]
Fatal error: Class 'Foobar\InexistentClass' not found in ...
</pre></div>
    </div>
   </div>
  <p></p>
 </div>

 
 <div class="refsect1 seealso" id="refsect1-function.spl-autoload-register-seealso">
  <h3 class="title">See Also</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li class="member"><span class="function"><a href="function.autoload.html" class="function" rel="rdfs-seeAlso">__autoload()</a> - Attempt to load undefined class</span></li>
   </ul>
  <p></p>
 </div>


</div>
<section id="usernotes">
 <div class="head"><h3 class="title">User Contributed Notes</h3></div><div id="allnotes">
  <div class="note" id="92514">  
  <a class="name">
  <strong class="user"><em>a dot schaffhirt at sedna-soft dot de</em></strong></a><div class="date" title="2009-07-27 07:05"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom92514">
<div class="phpcode"><code><span class="html">
Good news for PHP 5.3 users with namespaced classes:<br><br>When you create a subfolder structure matching the namespaces of the containing classes, you will never even have to define an autoloader.<br><br><span class="default">&lt;?php<br>&nbsp; &nbsp; spl_autoload_extensions</span><span class="keyword">(</span><span class="string">".php"</span><span class="keyword">); </span><span class="comment">// comma-separated list<br>&nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">();<br></span><span class="default">?&gt;<br></span><br>It is recommended to use only one extension for all classes. PHP (more exactly spl_autoload) does the rest for you and is even quicker than a semantically equal self-defined autoload function like this one:<br><br><span class="default">&lt;?php<br>&nbsp; &nbsp; </span><span class="keyword">function </span><span class="default">my_autoload </span><span class="keyword">(</span><span class="default">$pClassName</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; include(</span><span class="default">__DIR__ </span><span class="keyword">. </span><span class="string">"/" </span><span class="keyword">. </span><span class="default">$pClassName </span><span class="keyword">. </span><span class="string">".php"</span><span class="keyword">);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">"my_autoload"</span><span class="keyword">);<br></span><span class="default">?&gt;<br></span><br>I compared them with the following setting: There are 10 folders, each having 10 subfolders, each having 10 subfolders, each containing 10 classes.<br><br>To load and instantiate these 1000 classes (parameterless no-action constructor), the user-definded autoload function approach took 50ms longer in average than the spl_autoload function in a series of 10 command-line calls for each approach.<br><br>I made this benchmark to ensure that I don't recommend something that could be called "nice, but slow" later.<br><br>Best regards,</span>
</code></div>
  </div>
 </div>
  <div class="note" id="121435">  
  <a class="name">
  <strong class="user"><em>nemanja</em></strong></a><div class="date" title="2017-07-26 08:25"><strong>4 years ago</strong></div>
  <div class="text" id="Hcom121435">
<div class="phpcode"><code><span class="html">
Even when autoloading (SPL) is used, class inheritance does not seem to work. Simply the PHP engine is unable to find parent (inherited) class. PHP 5.6 and 7.0 behave exactly same on this, which beats the purpose of autoloading.<br><br>And IMHO it's easy to fix as the autoloader is able to find all first level classes w/o problems, it just needs to follow same path recursively on parents too.<br><br><span class="default">&lt;?php<br></span><span class="comment">//Using default SPL autoloader, with namespaces mapping 1:1 to directory structure, with file names being all lowercase. <br>//This works with first level classes only, for inheritance it does NOT work, it cannot find parent classes.<br></span><span class="default">spl_autoload_register</span><span class="keyword">();<br><br></span><span class="comment">//This is ugly but working code if you want to be able to autoload parent classes too.<br></span><span class="default">spl_autoload_register</span><span class="keyword">(function (</span><span class="default">$class</span><span class="keyword">){<br>&nbsp; &nbsp; require_once </span><span class="default">__DIR__ </span><span class="keyword">. </span><span class="string">'/' </span><span class="keyword">. </span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'\\'</span><span class="keyword">, </span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$class</span><span class="keyword">) . </span><span class="string">'.php'</span><span class="keyword">);<br>});</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="117805">  
  <a class="name">
  <strong class="user"><em>eyeofmidas at gmail dot com</em></strong></a><div class="date" title="2015-08-12 03:57"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom117805">
<div class="phpcode"><code><span class="html">
When switching from using __autoload() to using spl_autoload_register keep in mind that deserialization of the session can trigger class lookups.<br><br>This works as expected: <br><span class="default">&lt;?php<br>session_start</span><span class="keyword">();<br>function </span><span class="default">__autoload</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br>...<br>}<br></span><span class="default">?&gt;<br></span><br>This will result in "__PHP_Incomplete_Class_Name" errors when using classes deserialized from the session.<br><span class="default">&lt;?php<br>session_start</span><span class="keyword">();<br>function </span><span class="default">customAutoloader</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br>...<br>}<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">"customAutoloader"</span><span class="keyword">);<br></span><span class="default">?&gt;<br></span><br>So you need to make sure the spl_autoload_register is done BEFORE session_start() is called.<br><br>CORRECT:<br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">customAutoloader</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br>...<br>}<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">"customAutoloader"</span><span class="keyword">);<br></span><span class="default">session_start</span><span class="keyword">();<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="102180">  
  <a class="name">
  <strong class="user"><em>(delphists) at (apollo) dot (lv)</em></strong></a><div class="date" title="2011-02-01 01:57"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom102180">
<div class="phpcode"><code><span class="html">
When using spl_autoload_register() with class methods, it might seem that it can use only public methods, though it can use private/protected methods as well, if registered from inside the class:<br><span class="default">&lt;?php<br><br>&nbsp; &nbsp; </span><span class="keyword">class </span><span class="default">ClassAutoloader </span><span class="keyword">{<br>&nbsp; &nbsp; &nbsp; &nbsp; public function </span><span class="default">__construct</span><span class="keyword">() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$this</span><span class="keyword">, </span><span class="string">'loader'</span><span class="keyword">));<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; private function </span><span class="default">loader</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo </span><span class="string">'Trying to load '</span><span class="keyword">, </span><span class="default">$className</span><span class="keyword">, </span><span class="string">' via '</span><span class="keyword">, </span><span class="default">__METHOD__</span><span class="keyword">, </span><span class="string">"()\n"</span><span class="keyword">;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include </span><span class="default">$className </span><span class="keyword">. </span><span class="string">'.php'</span><span class="keyword">;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; </span><span class="default">$autoloader </span><span class="keyword">= new </span><span class="default">ClassAutoloader</span><span class="keyword">();<br><br>&nbsp; &nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Class1</span><span class="keyword">();<br>&nbsp; &nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Class2</span><span class="keyword">();<br><br></span><span class="default">?&gt;<br></span><br>Output:<br>--------<br>Trying to load Class1 via ClassAutoloader::loader()<br>Class1::__construct()<br>Trying to load Class2 via ClassAutoloader::loader()<br>Class2::__construct()</span>
</code></div>
  </div>
 </div>
  <div class="note" id="71155">  
  <a class="name">
  <strong class="user"><em>florent at mediagonale dot com</em></strong></a><div class="date" title="2006-11-14 01:19"><strong>14 years ago</strong></div>
  <div class="text" id="Hcom71155">
<div class="phpcode"><code><span class="html">
If your autoload function is a class method, you can call spl_autoload_register with an array specifying the class and the method to run.<br><br>* You can use a static method :<br><span class="default">&lt;?php<br><br></span><span class="keyword">class </span><span class="default">MyClass </span><span class="keyword">{<br>&nbsp; public static function </span><span class="default">autoload</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="comment">// ...<br>&nbsp; </span><span class="keyword">}<br>}<br><br></span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'MyClass'</span><span class="keyword">, </span><span class="string">'autoload'</span><span class="keyword">));<br></span><span class="default">?&gt;<br></span><br>* Or you can use an instance :<br><span class="default">&lt;?php<br></span><span class="keyword">class </span><span class="default">MyClass </span><span class="keyword">{<br>&nbsp; public function </span><span class="default">autoload</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="comment">// ...<br>&nbsp; </span><span class="keyword">}<br>}<br><br></span><span class="default">$instance </span><span class="keyword">= new </span><span class="default">MyClass</span><span class="keyword">();<br></span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$instance</span><span class="keyword">, </span><span class="string">'autoload'</span><span class="keyword">));<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="98746">  
  <a class="name">
  <strong class="user"><em>anthon at piwik dot org</em></strong></a><div class="date" title="2010-07-04 09:02"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom98746">
<div class="phpcode"><code><span class="html">
Think twice about throwing an exception from a registered autoloader.<br><br>If you have multiple autoloaders registered, and one (or more) throws an exception before a later autoloader loads the class, stacked exceptions are thrown (and must be caught) even though the class was loaded successfully.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="117241">  
  <a class="name">
  <strong class="user"><em>iam at thatguy dot co dot za</em></strong></a><div class="date" title="2015-05-08 07:19"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom117241">
<div class="phpcode"><code><span class="html">
<span class="default">&lt;?php<br><br>&nbsp; &nbsp; </span><span class="comment">// Example to auto-load class files from multiple directories using the SPL_AUTOLOAD_REGISTER method.<br>&nbsp; &nbsp; // It auto-loads any file it finds starting with class.&lt;classname&gt;.php (LOWERCASE), eg: class.from.php, class.db.php<br>&nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(function(</span><span class="default">$class_name</span><span class="keyword">) {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// Define an array of directories in the order of their priority to iterate through.<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$dirs </span><span class="keyword">= array(<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'project/'</span><span class="keyword">, </span><span class="comment">// Project specific classes (+Core Overrides)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'classes/'</span><span class="keyword">, </span><span class="comment">// Core classes example<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'tests/'</span><span class="keyword">,&nbsp;&nbsp; </span><span class="comment">// Unit test classes, if using PHP-Unit<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// Looping through each directory to load all the class files. It will only require a file once.<br>&nbsp; &nbsp; &nbsp; &nbsp; // If it finds the same class in a directory later on, IT WILL IGNORE IT! Because of that require once!<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">foreach( </span><span class="default">$dirs </span><span class="keyword">as </span><span class="default">$dir </span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (</span><span class="default">file_exists</span><span class="keyword">(</span><span class="default">$dir</span><span class="keyword">.</span><span class="string">'class.'</span><span class="keyword">.</span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">$class_name</span><span class="keyword">).</span><span class="string">'.php'</span><span class="keyword">)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_once(</span><span class="default">$dir</span><span class="keyword">.</span><span class="string">'class.'</span><span class="keyword">.</span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">$class_name</span><span class="keyword">).</span><span class="string">'.php'</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; });</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="111875">  
  <a class="name">
  <strong class="user"><em>a dot schaffhirt at sedna-soft dot de</em></strong></a><div class="date" title="2013-04-07 01:42"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom111875">
<div class="phpcode"><code><span class="html">
What I said here previously is only true on Windows. The built-in default autoloader that is registered when you call spl_autoload_register() without any arguments simply adds the qualified class name plus the registered file extension (.php) to each of the include paths and tries to include that file.<br><br>Example (on Windows):<br><br>include paths:<br>- "."<br>- "d:/projects/phplib"<br><br>qualified class name to load:<br>network\http\rest\Resource<br><br>Here's what happens:<br><br>PHP tries to load<br>'.\\network\\http\\rest\\Resource.php'<br>-&gt; file not found<br><br>PHP tries to load<br>'d:/projects/phplib\\network\\http\\rest\\Resource.php'<br>-&gt; file found and included<br><br>Note the slashes and backslashes in the file path. On Windows this works perfectly, but on a Linux machine, the backslashes won't work and additionally the file names are case-sensitive.<br><br>That's why on Linux the quick-and-easy way would be to convert these qualified class names to slashes and to lowercase and pass them to the built-in autoloader like so:<br><br><span class="default">&lt;?php<br>spl_autoload_register</span><span class="keyword">(<br>&nbsp; function (</span><span class="default">$pClassName</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="default">spl_autoload</span><span class="keyword">(</span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">"\\"</span><span class="keyword">, </span><span class="string">"/"</span><span class="keyword">, </span><span class="default">$pClassName</span><span class="keyword">)));<br>&nbsp; }<br>);<br></span><span class="default">?&gt;<br></span><br>But this means, you have to save all your classes with lowercase file names. Otherwise, if you omit the strtolower call, you have to use the class names exactly as specified by the file name, which can be annoying for class names that are defined with non-straightforward case like e. g. XMLHttpRequest.<br><br>I prefer the lowercase approach, because it is easier to use and the file name conversion can be done automatically on deploying.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="96804">  
  <a class="name">
  <strong class="user"><em>Anonymous</em></strong></a><div class="date" title="2010-03-16 08:30"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom96804">
<div class="phpcode"><code><span class="html">
Be careful using this function on case sensitive file systems.<br><br><span class="default">&lt;?php<br>spl_autoload_extensions</span><span class="keyword">(</span><span class="string">'.php'</span><span class="keyword">);<br></span><span class="default">spl_autoload_register</span><span class="keyword">();<br></span><span class="default">?&gt;<br></span><br>I develop on OS X and everything was working fine. But when releasing to my linux server, none of my class files were loading. I had to lowercase all my filenames, because calling a class "DatabaseObject" would try including "databaseobject.php", instead of "DatabaseObject.php"<br><br>I think i'll go back to using the slower __autoload() function, just so i can keep my class files readable</span>
</code></div>
  </div>
 </div>
  <div class="note" id="95456">  
  <a class="name">
  <strong class="user"><em>rayro at gmx dot de</em></strong></a><div class="date" title="2010-01-04 03:14"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom95456">
<div class="phpcode"><code><span class="html">
It is never a good idea and a unconscienable concept to create the classes in the autoload function via eval. <br>It should be a nice feature with these Exception, but i think anyone is able to handle it without this method although. Atm i dont realize for what this is good for...<br><br>As i might note, class_exists() will ever define the classes u only want to check for existance, and will therefor ever return true:<br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">EvalIsEvil</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br>&nbsp; eval(</span><span class="string">'class '</span><span class="keyword">.</span><span class="default">$className</span><span class="keyword">.</span><span class="string">'{}'</span><span class="keyword">);<br>}<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'EvalIsEvil'</span><span class="keyword">);<br>if (</span><span class="default">class_exists</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">=</span><span class="string">"IsMyModuleHere"</span><span class="keyword">)) {<br>&nbsp; </span><span class="comment">// this is no module, but get there with eval()...<br>&nbsp; </span><span class="keyword">return new </span><span class="default">$s</span><span class="keyword">();<br>}<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="113251">  
  <a class="name">
  <strong class="user"><em>phil at propcom dot co dot uk</em></strong></a><div class="date" title="2013-09-18 08:36"><strong>7 years ago</strong></div>
  <div class="text" id="Hcom113251">
<div class="phpcode"><code><span class="html">
It is important to note that the autoloader will NOT be called if an E_STRICT error triggers the error handler which, in turn, tries to use classes which are not yet loaded. <br><br>In this instance, you should manually load classes required by the error handler.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="118061">  
  <a class="name">
  <strong class="user"><em>kakkau at grr dot la</em></strong></a><div class="date" title="2015-09-28 05:11"><strong>5 years ago</strong></div>
  <div class="text" id="Hcom118061">
<div class="phpcode"><code><span class="html">
A note on registering autoloading functions with additional parameters.<br><br>./alf.home.php<br><span class="default">&lt;?php<br></span><span class="comment">/*<br> * class containing an autoloading function alias ALF :)<br> */<br></span><span class="keyword">class </span><span class="default">ALF </span><span class="keyword">{<br>&nbsp; public function </span><span class="default">haaahaaahaaa</span><span class="keyword">(</span><span class="default">$class </span><span class="keyword">= </span><span class="string">"ALF"</span><span class="keyword">, </span><span class="default">$param </span><span class="keyword">= </span><span class="string">"Melmac"</span><span class="keyword">) {<br>&nbsp; &nbsp; echo </span><span class="string">"I am "</span><span class="keyword">.</span><span class="default">$class</span><span class="keyword">.</span><span class="string">" from "</span><span class="keyword">.</span><span class="default">$param</span><span class="keyword">.</span><span class="string">".\n"</span><span class="keyword">;<br>&nbsp; }<br>}<br></span><span class="default">?&gt;<br></span><br>./kate.melmac.php<br><span class="default">&lt;?php<br></span><span class="keyword">require_once(</span><span class="string">"alf.home.php"</span><span class="keyword">);<br></span><span class="comment">/*<br> * the normal way is to get ALF <br> * and register an autoloading function<br> */<br></span><span class="default">$alf </span><span class="keyword">= new </span><span class="default">ALF</span><span class="keyword">();<br></span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$alf</span><span class="keyword">,</span><span class="string">'haaahaaahaaa'</span><span class="keyword">));<br></span><span class="default">$alf</span><span class="keyword">-&gt;</span><span class="default">haaahaaahaaa</span><span class="keyword">(); </span><span class="comment">// ALF is from Melmac :)<br>/*<br> * now lets try to autoload a class<br> */<br></span><span class="keyword">@</span><span class="default">$kate </span><span class="keyword">= new </span><span class="default">Kate</span><span class="keyword">(); </span><span class="comment">// this throws a fatal error because<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Kate is NOT from Melmac :)<br></span><span class="default">?&gt;<br></span>I am ALF from Melmac.<br>I am Kate from Melmac.<br><br>./kate.earth.php<br><span class="default">&lt;?php<br></span><span class="keyword">require_once(</span><span class="string">"alf.home.php"</span><span class="keyword">);<br></span><span class="comment">/*<br> * BUT what if we want to correct Kates origin ?<br> *&nbsp; &nbsp;&nbsp; How can one pass parameters to an autoloading function <br> *&nbsp; &nbsp;&nbsp; upon registering?<br> *<br> * spl_autoload_register is not suitable for that <br> *&nbsp;&nbsp; but we can try is to define a callable during registration<br> */<br></span><span class="default">spl_autoload_register</span><span class="keyword">(function(</span><span class="default">$class</span><span class="keyword">){ <br>&nbsp; </span><span class="default">call_user_func</span><span class="keyword">(array(new </span><span class="default">ALF</span><span class="keyword">(),</span><span class="string">'haaahaaahaaa'</span><span class="keyword">), </span><span class="default">$class</span><span class="keyword">, </span><span class="string">"Earth"</span><span class="keyword">); });<br></span><span class="comment">/*<br> * now lets try again to autoload a class<br> * Kate will still not be found but we corrected her origin :)<br> */<br></span><span class="keyword">@</span><span class="default">$kate </span><span class="keyword">= new </span><span class="default">Kate</span><span class="keyword">(); </span><span class="comment">// Kate is from Earth :)<br>/*<br> * NOTE: that you cannot pass $this or another object created <br> *&nbsp; &nbsp; &nbsp;&nbsp; outside of the callable context using the <br> *&nbsp; &nbsp; &nbsp;&nbsp; registering way above. therefor you should swap your autoloading<br> *&nbsp; &nbsp; &nbsp;&nbsp; function to a seperate class as done at the beginning with ALF.<br> *<br> * NOTE: you may not able to unregister your autoloading function<br> *&nbsp; &nbsp; &nbsp;&nbsp; directly as an instance was created in another context<br> */<br></span><span class="default">?&gt;<br></span>I am Kate from Earth.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="96952">  
  <a class="name">
  <strong class="user"><em>sebastian dot krebs at kingcrunch dot de</em></strong></a><div class="date" title="2010-03-24 10:54"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom96952">
<div class="phpcode"><code><span class="html">
It seems, that&nbsp; spl_autoload tests, if the class exists, after calling every registered loader. So it breaks the chain, if the class exists and will not call the other loaders
<br>
<br><span class="default">&lt;?php
<br></span><span class="keyword">function </span><span class="default">a </span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) {
<br>&nbsp; echo </span><span class="string">"a\n"</span><span class="keyword">;
<br>&nbsp; class </span><span class="default">Bla </span><span class="keyword">{} </span><span class="comment">// Usually "include 'path/to/file.php';"
<br></span><span class="keyword">}
<br>function </span><span class="default">b </span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) {
<br>&nbsp; echo </span><span class="string">"b\n"</span><span class="keyword">;
<br>}
<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'a'</span><span class="keyword">);
<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'b'</span><span class="keyword">);
<br>
<br></span><span class="default">$c </span><span class="keyword">= new </span><span class="default">Bla</span><span class="keyword">();
<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="121141">  
  <a class="name">
  <strong class="user"><em>rnealxp at yahoo dot com</em></strong></a><div class="date" title="2017-05-27 06:58"><strong>4 years ago</strong></div>
  <div class="text" id="Hcom121141">
<div class="phpcode"><code><span class="html">
I now utilize spl_autoload_register and there's no turning back. So let me gather here for you what I've learned...<br>1.) the issue mentioned in these docs about case-sensitivity of filenames (Windows vs Linux/Mac): it only comes into play if you don't provide your own custom function as an argument when calling spl_autoload_register. Your function is to accept a single argument which will be the class name that your code is currently trying to access. I observe that the class name comes in with the same letter-casing as that you are actually using in your code base (mixed-case or not). I am not doing/using namespaces, but as a best practice, and to make your implementation straight-forward and predictable, go with fileName===className (1:1).<br>2.) I often refactor my code-base's directory structure as my code base morphs. I'm not using namespaces, but even if I were, I would want a decoupling between my namespace hierarchy and my directory structure hierarchy. I like my directory hierarchies to be intuitive for getting to code I want to work with. To save myself from having to manually tell my autoloader the path to each file/class, I cache a couple of arrays in static variables that store just the file/class name in the one array and the folder path to the file in the other. After the cache (static vars) have been set on the first call to my function, it's just a matter of looking up in the filename array. For safety, and to be problem-free, no two php filenames should be identical across all of your directory hierarchy (your namespace)--I favor this practice anyways, and accordingly, I favor unique class names across my single namespace (despite it not yet explicitly defined). I did build in a check in my function to ensure all php file names/classes are unique.<br>3.) I converted many, many files that once had sets of functions in the global space to *abstract classes* that have private static variables and methods and of course also public static methods. So those sets of functions are now encapsulated in objects, and those objects are now auto-loaded. Simply for this benefit I will never again have a function in the global space other than my auto-loader function and other exceptions such as that.<br>4.) My auto-loader function uses only built-in php language constructs and operations and has no outside dependencies.<br>5.) If you utilize the function class_exists() in your codebase somewhere, realize that unless you are passing the second arg as false, you will trigger the autoloader to load that class. I stumbled on this of course. My use-case is that I don't want the class loaded: I only wanted to take some action if the class was being used (in an error-handler method).<br>6.) If you use the function method_exists(), you will definitely trigger the class to be loaded (which makes sense since you have already decided to drill down to looking for a specific method).<br>7.) I credit someone else's idea here: I also elected to call an init() method for the class being loaded should it exist. This saves me from having to manually call from the outside, let alone managing how and from where the call should be made. It is so useful to get your object set up and ready to do work in an automated fashion such as this.<br>8.) as another said, I also use require() and not require_once() as the first is enough to generate an error and if already loaded the function will not have been called.<br>9.) If for some reason I fail to find a class name in my cached arrays, I knowingly still call require(), passing the class name I had not accounted for in order to generate and reveal the problem (which of course is not anticipated!).<br>10.) Again, I ensure uniqueness across all class names. If I observe non-uniqueness, I again do a faulty call to require() like this: require('FoundMultiplesOfClassFile.php'); to reveal the problem. (I don't yet, and you likely should not, have any sophisticated error-handler registered so this is as good as anything else to me).</span>
</code></div>
  </div>
 </div>
  <div class="note" id="126119">  
  <a class="name">
  <strong class="user"><em>kuzawinski dot marcin at nospam dot gmail dot com</em></strong></a><div class="date" title="2021-05-29 05:36"><strong>3 months ago</strong></div>
  <div class="text" id="Hcom126119">
<div class="phpcode"><code><span class="html">
Since PHP 8.0 spl_autoload_register() will always throw a TypeError on invalid arguments, therefore the second argument `throw` is ignored and a notice will be emitted if it is set to False.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="114042">  
  <a class="name">
  <strong class="user"><em>hajo-p</em></strong></a><div class="date" title="2014-01-05 05:25"><strong>7 years ago</strong></div>
  <div class="text" id="Hcom114042">
<div class="phpcode"><code><span class="html">
if you have a dir-structure like "/abc/def/ghi", your index.php lies in the top directory, but you want to use namespaces starting with "def" or "ghi":
<br>
<br>you can switch the namespace root directory of php with e.g. set_include_path(__DIR__ . '/abc') and afterwards define + use your namespaces with the simple spl_autoload_register() function without any arguments supplied.
<br>
<br>remember that php handlers "cli" and "cli-server" are special cases.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="110382">  
  <a class="name">
  <strong class="user"><em>daniel at amnistechnology dot com</em></strong></a><div class="date" title="2012-10-17 09:57"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom110382">
<div class="phpcode"><code><span class="html">
Cleverly - and usefully - I have noticed that (on PHP 5.3 at least) these autoloaders "kick in" even when you call a public static method of an as-yet-unloaded all static class.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="78122">  
  <a class="name">
  <strong class="user"><em>stanlemon at mac dot com</em></strong></a><div class="date" title="2007-09-28 10:20"><strong>13 years ago</strong></div>
  <div class="text" id="Hcom78122">
<div class="phpcode"><code><span class="html">
Editorial note: The appropriate PHP bug that requests behavior this function emulates is <a rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=42823</a> . This function does NOT work if there has been an array($obj, 'nonStaticMethod') registered in the autoload stack--while the autoload will be removed, it will be re-registered incorrectly.
<br>
<br>The spl_autoload_register() method registers functions in its stack in the order that spl_autoload_register() was called, and subsequently if you want an autoload function to override previous autoload functions you will either need to unregister the previous ones or change the order of the autoload stack.
<br>
<br>For example, say in your default implementation of an autoload function you throw an exception if the class cannot be found, or perhaps a fatal error.&nbsp; Later on in your code you add a second implementation of an autoload function which will load a library that the previous method would fail on.&nbsp; This will not call the second autoloader method first, but rather will continue to error out on the first method.
<br>
<br>As previously mentioned, you can unregister the existing autoloader that errors out, or you can create a mechanism for unregistering and re-registering the autoloaders in the order you want.
<br>
<br>Here is a sample/example of how you might consider re-registering autoloaders so that the newest autoloader is called first, and the oldest last:
<br>
<br><span class="default">&lt;?php
<br>
<br></span><span class="comment">// Editorial notes: Small bug and compatibility fixes
<br>// added to the function
<br>
<br></span><span class="keyword">function </span><span class="default">spl_autoload_preregister</span><span class="keyword">( </span><span class="default">$autoload </span><span class="keyword">) {
<br>&nbsp; &nbsp; </span><span class="comment">// No functions currently in the stack.
<br>&nbsp; &nbsp; </span><span class="keyword">if ( (</span><span class="default">$funcs </span><span class="keyword">= </span><span class="default">spl_autoload_functions</span><span class="keyword">()) === </span><span class="default">false </span><span class="keyword">) {
<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$autoload</span><span class="keyword">);
<br>&nbsp; &nbsp; } else {
<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// Unregister existing autoloaders...
<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$compat </span><span class="keyword">=
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">version_compare</span><span class="keyword">(</span><span class="default">PHP_VERSION</span><span class="keyword">, </span><span class="string">'5.1.2'</span><span class="keyword">, </span><span class="string">'&lt;='</span><span class="keyword">) &amp;&amp;
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">version_compare</span><span class="keyword">(</span><span class="default">PHP_VERSION</span><span class="keyword">, </span><span class="string">'5.1.0'</span><span class="keyword">, </span><span class="string">'&gt;='</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; foreach (</span><span class="default">$funcs </span><span class="keyword">as </span><span class="default">$func</span><span class="keyword">) {
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">)) {
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// :TRICKY: There are some compatibility issues and some
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // places where we need to error out
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$reflector </span><span class="keyword">= new </span><span class="default">ReflectionMethod</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">$func</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!</span><span class="default">$reflector</span><span class="keyword">-&gt;</span><span class="default">isStatic</span><span class="keyword">()) {
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new </span><span class="default">Exception</span><span class="keyword">(</span><span class="string">'
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This function is not compatible
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with non-static object methods due to PHP Bug #44144.
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// Suprisingly, spl_autoload_register supports the
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Class::staticMethod callback format, although call_user_func doesn't
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">if (</span><span class="default">$compat</span><span class="keyword">) </span><span class="default">$func </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">(</span><span class="string">'::'</span><span class="keyword">, </span><span class="default">$func</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">spl_autoload_unregister</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; }
<br>&nbsp; &nbsp; &nbsp; &nbsp; 
<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// Register the new one, thus putting it at the front of the stack...
<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$autoload</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; 
<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// Now, go back and re-register all of our old ones.
<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">foreach (</span><span class="default">$funcs </span><span class="keyword">as </span><span class="default">$func</span><span class="keyword">) {
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; }
<br>&nbsp; &nbsp; }
<br>}
<br>
<br></span><span class="default">?&gt;
<br></span>
<br>Note: I have not tested this for overhead, so I am not 100% sure what the performance implication of the above example are.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="73146">  
  <a class="name">
  <strong class="user"><em>harvey dot NO_SPAM dot robin at gmail dot com</em></strong></a><div class="date" title="2007-02-10 05:54"><strong>14 years ago</strong></div>
  <div class="text" id="Hcom73146">
<div class="phpcode"><code><span class="html">
This function is smart enough not to add the same loader twice.&nbsp; This seems to work for all of the different loader formats.&nbsp; Example:<br><br><span class="default">&lt;?php<br></span><span class="keyword">class </span><span class="default">ALoader<br></span><span class="keyword">{<br>&nbsp; static function </span><span class="default">load</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) { return </span><span class="default">true</span><span class="keyword">; }<br>}<br><br>function </span><span class="default">anotherLoader</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br>&nbsp; return </span><span class="default">true</span><span class="keyword">;<br>}<br><br></span><span class="default">$F </span><span class="keyword">= new </span><span class="default">ALoader</span><span class="keyword">;<br><br></span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'ALoader'</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br></span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'ALoader'</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br></span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$F</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'anotherLoader'</span><span class="keyword">);<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'anotherLoader'</span><span class="keyword">);<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">spl_autoload_functions</span><span class="keyword">());<br><br></span><span class="comment">/*<br> * Results on PHP5.2 CLI, linux.<br> * array(2) {<br> *&nbsp; [0]=&gt;<br> *&nbsp; array(2) {<br> *&nbsp; &nbsp; [0]=&gt;<br> *&nbsp; &nbsp; string(7) "ALoader"<br> *&nbsp; &nbsp; [1]=&gt;<br> *&nbsp; &nbsp; string(4) "load"<br> *&nbsp; }<br> *&nbsp; [1]=&gt;<br> *&nbsp; string(13) "anotherLoader"<br> * }<br> */<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="118787">  
  <a class="name">
  <strong class="user"><em>joneschrisan at aol dot com</em></strong></a><div class="date" title="2016-02-05 04:11"><strong>5 years ago</strong></div>
  <div class="text" id="Hcom118787">
<div class="phpcode"><code><span class="html">
Looks like on the latest update of debian php passing no params to spl_autoload doesn't work on linux any more.<br><br>It is failing to replace the \'s in the namespace with /'s for file paths.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="113362">  
  <a class="name">
  <strong class="user"><em>Kurd the Great</em></strong></a><div class="date" title="2013-10-01 04:13"><strong>7 years ago</strong></div>
  <div class="text" id="Hcom113362">
<div class="phpcode"><code><span class="html">
if(!defined('BASE_PATH')) {<br>&nbsp; &nbsp; define('BASE_PATH', dirname(__FILE__) . '/');<br>&nbsp; &nbsp; require BASE_PATH . 'Autoloader.php';<br>&nbsp; &nbsp; Autoloader::Register();<br>}<br><br>class Autoloader<br>{<br>&nbsp; &nbsp; public static function Register() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return spl_autoload_register(array('Autoloader', 'Load'));<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public static function Load($strObjectName) {<br>&nbsp; &nbsp; &nbsp; &nbsp; if(class_exists($strObjectName) === false) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; $strObjectFilePath = BASE_PATH . $strObjectName . '.php';<br>&nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; if((file_exists($strObjectFilePath) === false) || (is_readable($strObjectFilePath) === false)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; require($strObjectFilePath);<br>&nbsp; &nbsp; }<br>}</span>
</code></div>
  </div>
 </div>
  <div class="note" id="116811">  
  <a class="name">
  <strong class="user"><em>xavier dot bouhours at free dot fr</em></strong></a><div class="date" title="2015-03-03 03:55"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom116811">
<div class="phpcode"><code><span class="html">
// Get last class version <br><br>&nbsp; &nbsp; if( !function_exists('classAutoLoader') )<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; function classAutoLoader($className)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $classFiles&nbsp; &nbsp;&nbsp; = array() ;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $classFile&nbsp; &nbsp;&nbsp; = FALSE ;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $classDir&nbsp; &nbsp; &nbsp; &nbsp; = __DIR__ .'/'&nbsp; ;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Get all files<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $files&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = scandir( $classDir ) ;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach ( $files as $url )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Verifie if file is : Name + class + version + extension<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if( is_file($classDir.$url) &amp;&amp; preg_match('/([^\.]+)\.class\.([\d\.]+)\.(.+)$/', $url, $m ) )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Verifie finded file<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if( $className == $m[1] )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Get previous version or init<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $previous = isset( $classFiles[$m[1]] ) ? $classFiles[$m[1]] : 0 ;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Get last version<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if( $previous&lt;$m[2] )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $classFiles[ $m[1] ] = $m[2] ; // version<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $classFile = $classDir.$url ;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } ;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if( !class_exists($className) ) include( $classFile );<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; spl_autoload_register('classAutoLoader') ;</span>
</code></div>
  </div>
 </div>
  <div class="note" id="116706">  
  <a class="name">
  <strong class="user"><em>neolium at gmail dot com</em></strong></a><div class="date" title="2015-02-13 01:00"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom116706">
<div class="phpcode"><code><span class="html">
This autoload will find every class you call if you put each one in a different file.<br><br>It walks into every directory recursivly from the root you specify in the $root var.<br><br>You can specify the folders ou don't want to walk in (e.g you won't find any class in a 'view' folder on an MVC project) in the $dir_to_not_look_in array;<br><br>spl_autoload_register(function($class) {<br><br>&nbsp; &nbsp; $root = 'my/root/path';<br>&nbsp; &nbsp; $file = $class . '.php';<br>&nbsp; &nbsp; $dir_to_not_look_in = array($directories, $to, $not, $look, $in);<br><br>&nbsp; &nbsp; if(!function_exists('load')) {<br>&nbsp; &nbsp; &nbsp; function load($dir, $file) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(file_exists($dir . '/' . $file)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_once $dir . '/' . $file;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(scandir($dir) as $value) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(is_dir($dir. '/' . $value) &amp;&amp; !in_array($value, $dir_to_no_look_in))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; load($dir. '/' . $value, $file);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; };&nbsp; <br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; load($root, $file);<br>&nbsp; &nbsp; <br>});</span>
</code></div>
  </div>
 </div>
  <div class="note" id="115154">  
  <a class="name">
  <strong class="user"><em>nmmm at nmmm dot nu</em></strong></a><div class="date" title="2014-06-04 02:17"><strong>7 years ago</strong></div>
  <div class="text" id="Hcom115154">
<div class="phpcode"><code><span class="html">
spl_autoload_register() can be used with include_path.<br><br>suppose in current directory we have directory "a", and inside there is directory "test" and inside is test.php :<br><br>&lt;?<br>namespace test;<br>class test{<br>&nbsp; &nbsp; &nbsp; &nbsp; function __construct(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo "Test created\n";<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>}<br>?&gt; <br><br>then we can use following code to load the class:<br>&lt;?<br>ini_set("include_path", "./a/");<br><br>spl_autoload_register();<br><br>$t = new \test\test();<br>?&gt;</span>
</code></div>
  </div>
 </div>
  <div class="note" id="122175">  
  <a class="name">
  <strong class="user"><em>n0mAd at example dot com</em></strong></a><div class="date" title="2017-12-24 07:49"><strong>3 years ago</strong></div>
  <div class="text" id="Hcom122175">
<div class="phpcode"><code><span class="html">
If you need to register the function when using namespaces, use the __NAMESPACE__ constant to define the name.<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">namespace </span><span class="default">Foobar</span><span class="keyword">;<br><br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'MyFunction'</span><span class="keyword">); </span><span class="comment">// incorrect<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'\MyFunction'</span><span class="keyword">);</span><span class="comment">// incorrect<br></span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">__NAMESPACE__ </span><span class="keyword">. </span><span class="string">'\MyFunction'</span><span class="keyword">); </span><span class="comment">// correct<br><br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="112804">  
  <a class="name">
  <strong class="user"><em>ali dot taheri dot m at gmail dot com</em></strong></a><div class="date" title="2013-07-24 02:23"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom112804">
<div class="phpcode"><code><span class="html">
I've made a little function that makes and registers a loader that seems to be safe and reliable although I'm not sure but it feels like a good idea to share, it took me some time to come up with it I hope it saves someone some time, <br><br><span class="default">&lt;?php<br><br></span><span class="keyword">function </span><span class="default">Loader</span><span class="keyword">(</span><span class="default">$root </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="default">$loaderFunction </span><span class="keyword">= </span><span class="default">create_function</span><span class="keyword">(</span><span class="string">'$class'</span><span class="keyword">, </span><span class="string">'include&nbsp; "' </span><span class="keyword">. </span><span class="default">$root </span><span class="keyword">. </span><span class="string">'$class.php";'</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$loaderFunction</span><span class="keyword">);<br>}<br><br></span><span class="default">?&gt;<br></span><br>if you have a file system exactly like your directory tree this function works perfectly, I haven't tested it on unix, but on windows, the default loader fails when your webpage isn't in the root directory, this makes sure that it won't cause a problem if your webpage is on a subdir too just pass ../ or more drived ../../ as root and it will work like a charm, note that i couldn't use anonymous functions because then the $root variable wouldn't have the same scope as the Loader function, so the function must be created on the fly. this is a good example of this functions usage<br><br>your class:<br>root/classes/support/classic.php<br><span class="default">&lt;?php<br><br>&nbsp; &nbsp; </span><span class="keyword">namespace </span><span class="default">classes</span><span class="keyword">/</span><span class="default">support</span><span class="keyword">;<br><br>&nbsp; &nbsp; class </span><span class="default">classic </span><span class="keyword">{<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// class def<br>&nbsp; &nbsp; </span><span class="keyword">}<br><br></span><span class="default">?&gt;<br></span><br>root/support/index.php<br><span class="default">&lt;?php<br><br>Loader</span><span class="keyword">(</span><span class="string">'../'</span><span class="keyword">);<br><br>use </span><span class="default">classes</span><span class="keyword">/</span><span class="default">support</span><span class="keyword">/</span><span class="default">classic</span><span class="keyword">;<br><br></span><span class="default">$cls </span><span class="keyword">= new </span><span class="default">classic</span><span class="keyword">();<br></span><span class="comment">//use $cls<br></span><span class="default">?&gt;<br></span><br>the loader will make a function like this:<br><span class="default">&lt;?php<br><br></span><span class="keyword">function(</span><span class="default">$class</span><span class="keyword">) {<br>&nbsp; &nbsp; include&nbsp; </span><span class="string">"../</span><span class="default">$class</span><span class="string">.php"</span><span class="keyword">;<br>}<br><br></span><span class="comment">//when and when the class is needed this will run the script which is indeed what we need:<br><br></span><span class="keyword">include </span><span class="string">'../classes/support/classic.php'</span><span class="keyword">;<br><br></span><span class="default">?&gt;<br></span><br>hope this helps folks;</span>
</code></div>
  </div>
 </div>
  <div class="note" id="112260">  
  <a class="name">
  <strong class="user"><em>sebastian at 34n dot de</em></strong></a><div class="date" title="2013-05-24 09:49"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom112260">
<div class="phpcode"><code><span class="html">
You can also use it like this:<br><br>&gt; spl_autoload_register ( array( new AutoloaderClass, 'method') );<br><br>or in PHP &gt; 5.3:<br><br>&gt; spl_autoload_register ( [ new My\Namespace\Autoloader, 'method'] );<br><br>On this way you dont have to create a variable, which is used once.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="107362">  
  <a class="name">
  <strong class="user"><em>Anonymous</em></strong></a><div class="date" title="2012-02-03 04:52"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom107362">
<div class="phpcode"><code><span class="html">
Note that when specifying the third parameter (prepend), the function will fail badly in PHP 5.2</span>
</code></div>
  </div>
 </div></div>

 
</section>    </section><!-- layout-content -->
        


  </div><!-- layout -->

  

    
 <!-- External and third party libraries. -->
 







<a id="toTop" href="javascript:;"><span id="toTopHover"></span><img width="40" height="40" alt="To Top" src="../../images/to-top%402x.png"></a>



<!-- Mirrored from www.php.net/manual/en/function.spl-autoload-register.php by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 11 Sep 2021 06:40:08 GMT -->

</body></html>