<html><!-- Mirrored from www.php.net/manual/en/regexp.reference.recursive.php by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 11 Sep 2021 10:47:49 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->


  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Recursive patterns</title>

 <link rel="shortcut icon" href="../../favicon.ico">
 <link rel="search" type="application/opensearchdescription+xml" href="http://php.net/phpnetimprovedsearch.src" title="Add PHP.net search">
 <link rel="alternate" type="application/atom+xml" href="https://www.php.net/releases/feed.php" title="PHP Release feed">
 <link rel="alternate" type="application/atom+xml" href="https://www.php.net/feed.atom" title="PHP: Hypertext Preprocessor">

 <link rel="canonical" href="regexp.reference.recursive.html">
 <link rel="shorturl" href="regexp.reference.recursive.html">
 <link rel="alternate" href="regexp.reference.recursive.html" hreflang="x-default">

 <link rel="contents" href="index-2.html">
 <link rel="index" href="reference.pcre.pattern.syntax.html">
 <link rel="prev" href="regexp.reference.comments.html">
 <link rel="next" href="regexp.reference.performance.html">

 <link rel="alternate" href="regexp.reference.recursive.html" hreflang="en">
 <link rel="alternate" href="https://www.php.net/manual/pt_BR/regexp.reference.recursive.php" hreflang="pt_BR">
 <link rel="alternate" href="https://www.php.net/manual/zh/regexp.reference.recursive.php" hreflang="zh">
 <link rel="alternate" href="https://www.php.net/manual/fr/regexp.reference.recursive.php" hreflang="fr">
 <link rel="alternate" href="https://www.php.net/manual/de/regexp.reference.recursive.php" hreflang="de">
 <link rel="alternate" href="https://www.php.net/manual/ja/regexp.reference.recursive.php" hreflang="ja">
 <link rel="alternate" href="https://www.php.net/manual/ro/regexp.reference.recursive.php" hreflang="ro">
 <link rel="alternate" href="https://www.php.net/manual/ru/regexp.reference.recursive.php" hreflang="ru">
 <link rel="alternate" href="https://www.php.net/manual/es/regexp.reference.recursive.php" hreflang="es">
 <link rel="alternate" href="https://www.php.net/manual/tr/regexp.reference.recursive.php" hreflang="tr">

<link rel="stylesheet" type="text/css" href="../../cached0aba.css?t=1539771603&amp;f=/fonts/Fira/fira.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached2ecf.css?t=1539765004&amp;f=/fonts/Font-Awesome/css/fontello.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cachedba57.css?t=1606338002&amp;f=/styles/theme-base.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached3afa.css?t=1627831203&amp;f=/styles/theme-medium.css" media="screen">

 <!--[if lte IE 7]>
 <link rel="stylesheet" type="text/css" href="https://www.php.net/styles/workarounds.ie7.css" media="screen">
 <![endif]-->

 <!--[if lte IE 8]>
 <script>
  window.brokenIE = true;
 </script>
 <![endif]-->

 <!--[if lte IE 9]>
 <link rel="stylesheet" type="text/css" href="https://www.php.net/styles/workarounds.ie9.css" media="screen">
 <![endif]-->

 <!--[if IE]>
 <script src="https://www.php.net/js/ext/html5.js"></script>
 <![endif]-->

 <base>


</head>
<body class="docs " style="">


<div class="headsup"><a href="https://www.php.net/conferences/index.php#id2021-09-08-1">Longhorn PHP 2021</a></div>
<nav id="trick"><div><dl>
<dt><a href="getting-started.html">Getting Started</a></dt>
	<dd><a href="introduction.html">Introduction</a></dd>
	<dd><a href="tutorial.html">A simple tutorial</a></dd>
<dt><a href="langref.html">Language Reference</a></dt>
	<dd><a href="language.basic-syntax.html">Basic syntax</a></dd>
	<dd><a href="language.types.html">Types</a></dd>
	<dd><a href="language.variables.html">Variables</a></dd>
	<dd><a href="language.constants.html">Constants</a></dd>
	<dd><a href="language.expressions.html">Expressions</a></dd>
	<dd><a href="language.operators.html">Operators</a></dd>
	<dd><a href="language.control-structures.html">Control Structures</a></dd>
	<dd><a href="language.functions.html">Functions</a></dd>
	<dd><a href="language.oop5.html">Classes and Objects</a></dd>
	<dd><a href="language.namespaces.html">Namespaces</a></dd>
	<dd><a href="language.errors.html">Errors</a></dd>
	<dd><a href="language.exceptions.html">Exceptions</a></dd>
	<dd><a href="language.generators.html">Generators</a></dd>
	<dd><a href="language.attributes.html">Attributes</a></dd>
	<dd><a href="language.references.html">References Explained</a></dd>
	<dd><a href="reserved.variables.html">Predefined Variables</a></dd>
	<dd><a href="reserved.exceptions.html">Predefined Exceptions</a></dd>
	<dd><a href="reserved.interfaces.html">Predefined Interfaces and Classes</a></dd>
	<dd><a href="context.html">Context options and parameters</a></dd>
	<dd><a href="wrappers.html">Supported Protocols and Wrappers</a></dd>
</dl>
<dl>
<dt><a href="security.html">Security</a></dt>
	<dd><a href="security.intro.html">Introduction</a></dd>
	<dd><a href="security.general.html">General considerations</a></dd>
	<dd><a href="security.cgi-bin.html">Installed as CGI binary</a></dd>
	<dd><a href="security.apache.html">Installed as an Apache module</a></dd>
	<dd><a href="security.sessions.html">Session Security</a></dd>
	<dd><a href="security.filesystem.html">Filesystem Security</a></dd>
	<dd><a href="security.database.html">Database Security</a></dd>
	<dd><a href="security.errors.html">Error Reporting</a></dd>
	<dd><a href="security.variables.html">User Submitted Data</a></dd>
	<dd><a href="security.hiding.html">Hiding PHP</a></dd>
	<dd><a href="security.current.html">Keeping Current</a></dd>
<dt><a href="features.html">Features</a></dt>
	<dd><a href="features.http-auth.html">HTTP authentication with PHP</a></dd>
	<dd><a href="features.cookies.html">Cookies</a></dd>
	<dd><a href="features.sessions.html">Sessions</a></dd>
	<dd><a href="features.xforms.html">Dealing with XForms</a></dd>
	<dd><a href="features.file-upload.html">Handling file uploads</a></dd>
	<dd><a href="features.remote-files.html">Using remote files</a></dd>
	<dd><a href="features.connection-handling.html">Connection handling</a></dd>
	<dd><a href="features.persistent-connections.html">Persistent Database Connections</a></dd>
	<dd><a href="features.commandline.html">Command line usage</a></dd>
	<dd><a href="features.gc.html">Garbage Collection</a></dd>
	<dd><a href="features.dtrace.html">DTrace Dynamic Tracing</a></dd>
</dl>
<dl>
<dt><a href="funcref.html">Function Reference</a></dt>
	<dd><a href="refs.basic.php.html">Affecting PHP's Behaviour</a></dd>
	<dd><a href="refs.utilspec.audio.html">Audio Formats Manipulation</a></dd>
	<dd><a href="refs.remote.auth.html">Authentication Services</a></dd>
	<dd><a href="refs.utilspec.cmdline.html">Command Line Specific Extensions</a></dd>
	<dd><a href="refs.compression.html">Compression and Archive Extensions</a></dd>
	<dd><a href="refs.crypto.html">Cryptography Extensions</a></dd>
	<dd><a href="refs.database.html">Database Extensions</a></dd>
	<dd><a href="refs.calendar.html">Date and Time Related Extensions</a></dd>
	<dd><a href="refs.fileprocess.file.html">File System Related Extensions</a></dd>
	<dd><a href="refs.international.html">Human Language and Character Encoding Support</a></dd>
	<dd><a href="refs.utilspec.image.html">Image Processing and Generation</a></dd>
	<dd><a href="refs.remote.mail.html">Mail Related Extensions</a></dd>
	<dd><a href="refs.math.html">Mathematical Extensions</a></dd>
	<dd><a href="refs.utilspec.nontext.html">Non-Text MIME Output</a></dd>
	<dd><a href="refs.fileprocess.process.html">Process Control Extensions</a></dd>
	<dd><a href="refs.basic.other.html">Other Basic Extensions</a></dd>
	<dd><a href="refs.remote.other.html">Other Services</a></dd>
	<dd><a href="refs.search.html">Search Engine Extensions</a></dd>
	<dd><a href="refs.utilspec.server.html">Server Specific Extensions</a></dd>
	<dd><a href="refs.basic.session.html">Session Extensions</a></dd>
	<dd><a href="refs.basic.text.html">Text Processing</a></dd>
	<dd><a href="refs.basic.vartype.html">Variable and Type Related Extensions</a></dd>
	<dd><a href="refs.webservice.html">Web Services</a></dd>
	<dd><a href="refs.utilspec.windows.html">Windows Only Extensions</a></dd>
	<dd><a href="refs.xml.html">XML Manipulation</a></dd>
	<dd><a href="refs.ui.html">GUI Extensions</a></dd>
</dl>
<dl>
<dt>Keyboard Shortcuts</dt><dt>?</dt>
<dd>This help</dd>
<dt>j</dt>
<dd>Next menu item</dd>
<dt>k</dt>
<dd>Previous menu item</dd>
<dt>g p</dt>
<dd>Previous man page</dd>
<dt>g n</dt>
<dd>Next man page</dd>
<dt>G</dt>
<dd>Scroll to bottom</dd>
<dt>g g</dt>
<dd>Scroll to top</dd>
<dt>g h</dt>
<dd>Goto homepage</dd>
<dt>g s</dt>
<dd>Goto search<br>(current page)</dd>
<dt>/</dt>
<dd>Focus search box</dd>
</dl></div></nav>
<div id="goto">
    <div class="search">
         <div class="text"></div>
         <div class="results"><ul></ul></div>
   </div>
</div>

  <div id="breadcrumbs" class="row-fluid">
    <div id="breadcrumbs-inner">
          
              
          <ul>
            <li><a href="index-2.html">PHP Manual</a></li>      <li><a href="funcref.html">Function Reference</a></li>      <li><a href="refs.basic.text.html">Text Processing</a></li>      <li><a href="book.pcre.html">PCRE</a></li>      <li><a href="pcre.pattern.html">PCRE Patterns</a></li>      <li><a href="reference.pcre.pattern.syntax.html">PCRE regex syntax</a></li>      </ul>
    </div>
  </div>




<div id="layout" class="clearfix">
  <section id="layout-content">
  <div id="regexp.reference.recursive" class="section">
  <h2 class="title">Recursive patterns</h2>
  <p class="para">
   Consider the problem of matching a  string  in  parentheses,
   allowing  for  unlimited nested parentheses. Without the use
   of recursion, the best that can be done is to use a  pattern
   that  matches  up  to some fixed depth of nesting. It is not
   possible to handle an arbitrary nesting depth. Perl 5.6  has
   provided   an  experimental  facility  that  allows  regular
   expressions to recurse (among other things).  The  special
   item (?R) is  provided for  the specific  case of recursion.
   This PCRE  pattern  solves the  parentheses  problem (assume
   the <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_EXTENDED</a>
   option is set so that white space is
   ignored):

   <code class="literal">\( ( (?&gt;[^()]+) | (?R) )* \)</code>
  </p>
  <p class="para">
   First it matches an opening parenthesis. Then it matches any
   number  of substrings which can either be a sequence of
   non-parentheses, or a recursive  match  of  the  pattern  itself
   (i.e. a correctly parenthesized substring). Finally there is
   a closing parenthesis.
  </p>
  <p class="para">
   This particular example pattern  contains  nested  unlimited
   repeats, and so the use of a once-only subpattern for matching
   strings of non-parentheses is  important  when  applying
   the  pattern to strings that do not match. For example, when
   it is applied to

   <code class="literal">(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</code>

   it yields "no match" quickly. However, if a  once-only  subpattern
   is  not  used,  the match runs for a very long time
   indeed because there are so many different ways the + and  *
   repeats  can carve up the subject, and all have to be tested
   before failure can be reported.
  </p>
  <p class="para">
   The values set for any capturing subpatterns are those  from
   the outermost level of the recursion at which the subpattern
   value is set. If the pattern above is matched against

   <code class="literal">(ab(cd)ef)</code>

   the value for the capturing parentheses is  "ef",  which  is
   the  last  value  taken  on  at the top level. If additional
   parentheses are added, giving

   <code class="literal">\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</code>
   then the string they capture
   is "ab(cd)ef", the contents of the top level parentheses. If
   there are more than 15 capturing parentheses in  a  pattern,
   PCRE  has  to  obtain  extra  memory  to store data during a
   recursion, which it does by using  pcre_malloc,  freeing  it
   via  pcre_free  afterwards. If no memory can be obtained, it
   saves data for the first 15 capturing parentheses  only,  as
   there is no way to give an out-of-memory error from within a
   recursion.
  </p>

  <p class="para">
   <code class="literal">(?1)</code>, <code class="literal">(?2)</code> and so on
   can be used for recursive subpatterns too. It is also possible to use named
   subpatterns: <code class="literal">(?P&gt;name)</code> or
   <code class="literal">(?&amp;name)</code>.
  </p>
  <p class="para">
   If the syntax for a recursive subpattern reference (either by number or
   by name) is used outside the parentheses to which it refers, it operates
   like a subroutine in a programming language. An earlier example
   pointed out that the pattern
   <code class="literal">(sens|respons)e and \1ibility</code>
   matches "sense and sensibility" and "response and responsibility", but
   not "sense and responsibility". If instead the pattern
   <code class="literal">(sens|respons)e and (?1)ibility</code>
   is used, it does match "sense and responsibility" as well as the other
   two strings. Such references must, however, follow the subpattern to
   which they refer.
  </p>

  <p class="para">
   The maximum length of a subject string is the largest positive number
   that an integer variable can hold. However, PCRE uses recursion to
   handle subpatterns and indefinite repetition. This means that the
   available stack space may limit the size of a subject string that can be
   processed by certain patterns.
  </p>

 </div>
<section id="usernotes">
 <div class="head"><h3 class="title">User Contributed Notes</h3></div><div id="allnotes">
  <div class="note" id="111935">  
  <a class="name">
  <strong class="user"><em>horvath at webarticum dot hu</em></strong></a><div class="date" title="2013-04-15 12:07"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom111935">
<div class="phpcode"><code><span class="html">
With the (?R) item you can link only to the full pattern, because it quasi equals to (?0). You can not use anchors, asserts etc., and you can only check that string CONTAINS a valid hierarchy or not.<br><br>This is wrong: ^\(((?&gt;[^()]+)|(?R))*\)$<br><br>However, you can bracketing the full expression, and replace (?R) to the relative link (?-2). This make it reusable. So you can check complex expressions, for example:<br><span class="default">&lt;?php<br><br>$bracket_system </span><span class="keyword">= </span><span class="string">"(\\(((?&gt;[^()]+)|(?-2))*\\))"</span><span class="keyword">; </span><span class="comment">// (reuseable)<br></span><span class="default">$bracket_systems </span><span class="keyword">= </span><span class="string">"((?&gt;[^()]+)?</span><span class="default">$bracket_system</span><span class="string">)*(?&gt;[^()]+)?"</span><span class="keyword">; </span><span class="comment">// (reuseable)<br></span><span class="default">$equation </span><span class="keyword">= </span><span class="string">"</span><span class="default">$bracket_systems</span><span class="string">=</span><span class="default">$bracket_systems</span><span class="string">"</span><span class="keyword">; </span><span class="comment">// Both side of the equation must be contain valid bracket systems<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$equation</span><span class="string">\$/"</span><span class="keyword">,</span><span class="string">"a*(a-(2a+2))=4(a+3)-2(a-(a-2))"</span><span class="keyword">)); </span><span class="comment">// Outputs 'int(1)'<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$equation</span><span class="string">\$/"</span><span class="keyword">,</span><span class="string">"a*(a-(2a+2)=4(a+3)-2(a-(a-2)))"</span><span class="keyword">)); </span><span class="comment">// Outputs 'int(0)'<br><br></span><span class="default">?&gt;<br></span><br>You can also catch multibyte quotes with the 'u' modifier (if you use UTF-8), eg:<br><span class="default">&lt;?php<br><br>$quoted </span><span class="keyword">= </span><span class="string">"(»((?&gt;[^»«]+)|(?-2))*«)"</span><span class="keyword">; </span><span class="comment">// (reuseable)<br></span><span class="default">$prompt </span><span class="keyword">= </span><span class="string">"[\\w ]+: </span><span class="default">$quoted</span><span class="string">"</span><span class="keyword">;<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$prompt</span><span class="string">\$/u"</span><span class="keyword">,</span><span class="string">"Your name: »write here«"</span><span class="keyword">)); </span><span class="comment">// Outputs 'int(1)'<br><br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="95568">  
  <a class="name">
  <strong class="user"><em>emanueledelgrande at email dot it</em></strong></a><div class="date" title="2010-01-09 03:47"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom95568">
<div class="phpcode"><code><span class="html">
The recursion in regular expressions is the only way to allow the parsing of HTML code with nested tags of indefinite depth.<br>It seems it's not yet a spreaded practice; not so much contents are available on the web regarding regexp recursion, and until now no user contribute notes have been published on this manual page.<br>I made several tests with complex patterns to get tags with specific attributes or namespaces, studying the recursion of a subpattern only instead of the full pattern.<br>Here's an example that may power a fast LL parser with recursive descent (<a rel="nofollow" target="_blank">http://en.wikipedia.org/wiki/Recursive_descent_parser</a>):<br><br>$pattern = "/&lt;([\w]+)([^&gt;]*?) (([\s]*\/&gt;)| (&gt;((([^&lt;]*?|&lt;\!\-\-.*?\-\-&gt;)| (?R))*)&lt;\/\\1[\s]*&gt;))/xsm";<br><br>The performances of a preg_match or preg_match_all function call over an avarage (x)HTML document are quite fast and may drive you to chose this way instead of classic DOM object methods, which have a lot of limits and are usually poor in performance with their workarounds, too.<br>I post a sample application in a brief function (easy to be turned into OOP), which returns an array of objects:<br><br><span class="default">&lt;?php<br></span><span class="comment">// test function:<br></span><span class="keyword">function </span><span class="default">parse</span><span class="keyword">(</span><span class="default">$html</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="comment">// I have split the pattern in two lines not to have long lines alerts by the PHP.net form:<br>&nbsp; &nbsp; </span><span class="default">$pattern </span><span class="keyword">= </span><span class="string">"/&lt;([\w]+)([^&gt;]*?)(([\s]*\/&gt;)|"</span><span class="keyword">.<br>&nbsp; &nbsp; </span><span class="string">"(&gt;((([^&lt;]*?|&lt;\!\-\-.*?\-\-&gt;)|(?R))*)&lt;\/\\1[\s]*&gt;))/sm"</span><span class="keyword">;<br>&nbsp; &nbsp; </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="default">$html</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">, </span><span class="default">PREG_OFFSET_CAPTURE</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">$elements </span><span class="keyword">= array();<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; foreach (</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">] as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$match</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$elements</span><span class="keyword">[] = (object)array(<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'node' </span><span class="keyword">=&gt; </span><span class="default">$match</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'offset' </span><span class="keyword">=&gt; </span><span class="default">$match</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'tagname' </span><span class="keyword">=&gt; </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'attributes' </span><span class="keyword">=&gt; isset(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]) ? </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">] : </span><span class="string">''</span><span class="keyword">,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'omittag' </span><span class="keyword">=&gt; (</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">4</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">1</span><span class="keyword">] &gt; -</span><span class="default">1</span><span class="keyword">), </span><span class="comment">// boolean<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="string">'inner_html' </span><span class="keyword">=&gt; isset(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">6</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]) ? </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">6</span><span class="keyword">][</span><span class="default">$key</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">] : </span><span class="string">''<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return </span><span class="default">$elements</span><span class="keyword">;<br>}<br><br></span><span class="comment">// random html nodes as example:<br></span><span class="default">$html </span><span class="keyword">= &lt;&lt;&lt;EOD<br></span><span class="string">&lt;div id="airport"&gt;<br>&nbsp; &nbsp; &lt;div geo:position="1.234324,3.455546" class="index"&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &lt;!-- comment test:<br>&nbsp; &nbsp; &nbsp; &nbsp; &lt;div class="index_top" /&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; --&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &lt;div class="element decorator"&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;ul class="lister"&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;li onclick="javascript:item.showAttribute('desc');"&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;h3 class="outline"&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;a href="<a rel="nofollow" target="_blank">http://php.net/manual/en/regexp.reference.recursive.php</a>" onclick="openPopup()"&gt;Link&lt;/a&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/h3&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;div class="description"&gt;Sample description&lt;/div&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/li&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/ul&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &lt;/div&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &lt;div class="clean-line"&gt;&lt;/div&gt;<br>&nbsp; &nbsp; &lt;/div&gt;<br>&lt;/div&gt;<br>&lt;div id="omittag_test" rel="rootChild" /&gt;<br></span><span class="keyword">EOD;<br><br></span><span class="comment">// application:<br></span><span class="default">$elements </span><span class="keyword">= </span><span class="default">parse</span><span class="keyword">(</span><span class="default">$html</span><span class="keyword">);<br><br>if (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$elements</span><span class="keyword">) &gt; </span><span class="default">0</span><span class="keyword">) {<br>&nbsp; &nbsp; echo </span><span class="string">"Elements found: &lt;b&gt;"</span><span class="keyword">.</span><span class="default">count</span><span class="keyword">(</span><span class="default">$elements</span><span class="keyword">).</span><span class="string">"&lt;/b&gt;&lt;br /&gt;"</span><span class="keyword">;<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; foreach (</span><span class="default">$elements </span><span class="keyword">as </span><span class="default">$element</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; echo </span><span class="string">"&lt;p&gt;Tpl node: &lt;pre&gt;"</span><span class="keyword">.</span><span class="default">htmlentities</span><span class="keyword">(</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">node</span><span class="keyword">).</span><span class="string">"&lt;/pre&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; Tagname: &lt;tt&gt;"</span><span class="keyword">.</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">tagname</span><span class="keyword">.</span><span class="string">"&lt;/tt&gt;&lt;br /&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; Attributes: &lt;tt&gt;"</span><span class="keyword">.</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">attributes</span><span class="keyword">.</span><span class="string">"&lt;/tt&gt;&lt;br /&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; Omittag: &lt;tt&gt;"</span><span class="keyword">.(</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">omittag </span><span class="keyword">? </span><span class="string">'true' </span><span class="keyword">: </span><span class="string">'false'</span><span class="keyword">).</span><span class="string">"&lt;/tt&gt;&lt;br /&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; Inner HTML: &lt;pre&gt;"</span><span class="keyword">.</span><span class="default">htmlentities</span><span class="keyword">(</span><span class="default">$element</span><span class="keyword">-&gt;</span><span class="default">inner_html</span><span class="keyword">).</span><span class="string">"&lt;/pre&gt;&lt;/p&gt;"</span><span class="keyword">;<br>&nbsp; &nbsp; }<br>}<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="102748">  
  <a class="name">
  <strong class="user"><em>Onyxagargaryll</em></strong></a><div class="date" title="2011-03-03 04:49"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom102748">
<div class="phpcode"><code><span class="html">
Here's an approach to create a multidimensional array according to a string's delimiters, i.e. we want to analyze...<br><br>"some text (aaa(b(c1)(c2)d)e)(test) more text"<br><br>... as multidimensional layers.<br><br><span class="default">&lt;?php<br>$string </span><span class="keyword">= </span><span class="string">"some text (aaa(b(c1)(c2)d)e)(test) more text"</span><span class="keyword">;<br><br></span><span class="comment">/*<br> * Analyses the string multidimensionally by its opening and closing delimiters<br> */<br></span><span class="keyword">function </span><span class="default">recursiveSplit</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$layer</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">"/\((([^()]*|(?R))*)\)/"</span><span class="keyword">,</span><span class="default">$string</span><span class="keyword">,</span><span class="default">$matches</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="comment">// iterate thru matches and continue recursive split<br>&nbsp; &nbsp; </span><span class="keyword">if (</span><span class="default">count</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">) &gt; </span><span class="default">1</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">count</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]); </span><span class="default">$i</span><span class="keyword">++) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (</span><span class="default">is_string</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">])) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">]) &gt; </span><span class="default">0</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo </span><span class="string">"&lt;pre&gt;Layer "</span><span class="keyword">.</span><span class="default">$layer</span><span class="keyword">.</span><span class="string">":&nbsp;&nbsp; "</span><span class="keyword">.</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">].</span><span class="string">"&lt;/pre&gt;&lt;br /&gt;"</span><span class="keyword">;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">recursiveSplit</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">][</span><span class="default">$i</span><span class="keyword">], </span><span class="default">$layer </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>}<br><br></span><span class="default">recursiveSplit</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">);<br><br></span><span class="comment">/*<br><br>Output:<br><br>Layer 0:&nbsp;&nbsp; aaa(b(c1)(c2)d)e<br><br>Layer 1:&nbsp;&nbsp; b(c1)(c2)d<br><br>Layer 2:&nbsp;&nbsp; c1<br><br>Layer 2:&nbsp;&nbsp; c2<br><br>Layer 0:&nbsp;&nbsp; test<br>*/<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="101523">  
  <a class="name">
  <strong class="user"><em>jonah at nucleussystems dot com</em></strong></a><div class="date" title="2010-12-21 06:18"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom101523">
<div class="phpcode"><code><span class="html">
An unexpected behavior came up that introduced a very hard-to-track bug in some code I was working on.&nbsp; It has to do with the preg_match_all PREG_OFFSET_CAPTURE flag.&nbsp; When you capture the offset of a sub-match, it's offset is given _relative_ to it's parent.&nbsp; For example, if you extract the value between &lt; and &gt; recursively in this string:<br><br>&lt;this is a &lt;string&gt;&gt;<br><br>You will get an array that looks like this:<br><br>Array<br>(<br>&nbsp; &nbsp; [0] =&gt; Array<br>&nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array<br>&nbsp; &nbsp; &nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; &lt;this is a &lt;string&gt;&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [1] =&gt; 0<br>&nbsp; &nbsp; &nbsp; &nbsp; )<br>&nbsp; &nbsp; &nbsp; &nbsp; [1] =&gt; Array<br>&nbsp; &nbsp; &nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; this is a &lt;string&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [1] =&gt; 1<br>&nbsp; &nbsp; &nbsp; &nbsp; )<br>&nbsp; &nbsp; )<br>&nbsp; &nbsp; [1] =&gt; Array<br>&nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; Array<br>&nbsp; &nbsp; &nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; &lt;string&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [1] =&gt; 0<br>&nbsp; &nbsp; &nbsp; &nbsp; )<br>&nbsp; &nbsp; &nbsp; &nbsp; [1] =&gt; Array<br>&nbsp; &nbsp; &nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] =&gt; string<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [1] =&gt; 1<br>&nbsp; &nbsp; &nbsp; &nbsp; )<br>&nbsp; &nbsp; )<br>)<br><br>Notice that the offset in the last index is one, not the twelve we expected.&nbsp; The best way to solve this problem is to run over the results with a recursive function, adding the parent's offset.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="125521">  
  <a class="name">
  <strong class="user"><em>mzvarik at gmail dot com</em></strong></a><div class="date" title="2020-11-18 10:53"><strong>9 months ago</strong></div>
  <div class="text" id="Hcom125521">
<div class="phpcode"><code><span class="html">
This regexp can be used for parsing IF conditions.<br><br>$str = '<br>(IF_MYVAR)My var is printed<br>(OR_MYVARTWO)My var two is printed<br>(OR_ANOTHER)if you use OR you don't have to END everytime<br>(ELSE)Whatever bro(END)<br><br>(IF_BLUE)Something (IF_SUPERB)super(END) blue - this is simple IF condition(END)<br>';<br><br>function isCondition($k) {<br>&nbsp; &nbsp; // put your user conditions here<br>&nbsp; &nbsp; $conds = [];<br>&nbsp; &nbsp; $conds['BLUE'] = true;<br>&nbsp; &nbsp; $conds['MYVARTWO'] = true;<br>&nbsp; &nbsp; $conds['ELSE'] = true; // always true<br>&nbsp; &nbsp;&nbsp; return $conds[$k];<br>}<br><br>function findConditions($str) {<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; $pattern = '~ \(if_([^\)]+)\) ((?: (?!\((end|if_)). | (?R) )*+) \(end\) ~xis';<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; $str = preg_replace_callback($pattern, function($m) {<br>&nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; $k = $m[1];<br>&nbsp; &nbsp; &nbsp; &nbsp; $v = $m[2];<br>&nbsp; &nbsp; &nbsp; &nbsp; $v = findConditions($v) ?: $v;<br>&nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; $ors = preg_split('~(?=\((OR_[^\)]+|ELSE))~is', $v);<br>&nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; $v = array_shift($ors); // hlavní<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; if (isCondition($k)) return findConditions($v);<br>&nbsp; &nbsp; &nbsp; &nbsp; else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach ($ors as $or) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list($k, $v) = explode(")", $or, 2);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $k = substr($k, 1);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (isCondition($k)) return findConditions($v);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; return ''; // no matching condition<br>&nbsp; &nbsp; }, $str);<br>&nbsp; &nbsp; return $str;<br>};<br><br>// will output:&nbsp; Whatever bro&nbsp; \n\n&nbsp; Something blue<br>echo findConditions($str);</span>
</code></div>
  </div>
 </div>
  <div class="note" id="119691">  
  <a class="name">
  <strong class="user"><em>Anonymous</em></strong></a><div class="date" title="2016-08-04 09:11"><strong>5 years ago</strong></div>
  <div class="text" id="Hcom119691">
<div class="phpcode"><code><span class="html">
sass parse sample<br><br><span class="default">&lt;?php<br><br>$data </span><span class="keyword">= </span><span class="string">'a { b { 1 } c { d { 2 } } }'</span><span class="keyword">;<br><br></span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/a (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br></span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/b (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br></span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/c (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br></span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/d (?&lt;R&gt;\{(?:[^{}]+|(?&amp;R))*\})/'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$m</span><span class="keyword">);<br><br></span><span class="comment">/*<br>Array (<br>&nbsp; &nbsp; [0] =&gt; a { b { 1 } c { d { 2 } } }<br>&nbsp; &nbsp; [R] =&gt; { b { 1 } c { d { 2 } } }<br>&nbsp; &nbsp; [1] =&gt; { b { 1 } c { d { 2 } } }<br>)<br>Array (<br>&nbsp; &nbsp; [0] =&gt; b { 1 }<br>&nbsp; &nbsp; [R] =&gt; { 1 }<br>&nbsp; &nbsp; [1] =&gt; { 1 }<br>)<br>Array (<br>&nbsp; &nbsp; [0] =&gt; c { d { 2 } }<br>&nbsp; &nbsp; [R] =&gt; { d { 2 } }<br>&nbsp; &nbsp; [1] =&gt; { d { 2 } }<br>)<br>Array (<br>&nbsp; &nbsp; [0] =&gt; d { 2 }<br>&nbsp; &nbsp; [R] =&gt; { 2 }<br>&nbsp; &nbsp; [1] =&gt; { 2 }<br>)<br>*/</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="108927">  
  <a class="name">
  <strong class="user"><em>Daniel Klein</em></strong></a><div class="date" title="2012-06-06 04:18"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom108927">
<div class="phpcode"><code><span class="html">
The order of non-mutually exclusive alternatives within a recursed sub-pattern is important.<br><span class="default">&lt;?php<br>$pattern </span><span class="keyword">= </span><span class="string">'/^(?&lt;octet&gt;[01]?\d?\d|2[0-4]\d|25[0-5])(?:\.(?P&gt;octet)){3}$/'</span><span class="keyword">;<br></span><span class="default">?&gt;<br></span><br>You might expect that this pattern will match any IP address in dotted-decimal notation (e.g. '123.45.67.89'). The pattern is intended to match four octets in the following ranges: 0-9, 00-99 &amp; 000-255, each separated by a single dot. However, only the first octet can include values from 200-255; the remainder can only have values less than 200. The reason for this is that if the rest of the pattern fails, recursion is not back-tracked into to find an alternative match. The first part of the sub-pattern will match the first two digits of any octet from 200-255. The rest of the pattern will then fail because the third digit in the octet does not match either '\.' or '$'.<br><br><span class="default">&lt;?php<br>var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.67'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br></span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.200.45.67'</span><span class="keyword">)); </span><span class="comment">// 0 (false)<br></span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.200'</span><span class="keyword">)); </span><span class="comment">// 0 (false)<br></span><span class="default">?&gt;<br></span><br>The correct pattern is:<br><span class="default">&lt;?php<br>$pattern </span><span class="keyword">= </span><span class="string">'/^(?&lt;octet&gt;25[0-5]|2[0-4]\d|[01]?\d?\d)(?:\.(?P&gt;octet)){3}$/'</span><span class="keyword">;<br></span><span class="default">?&gt;<br></span><br>Note that the first two alternatives are mutually exclusive so their order is unimportant. The third alternative, however, is not mutually exclusive but it will now only match when the first two fail.<br><br><span class="default">&lt;?php<br>var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.67'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br></span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.200.45.67'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br></span><span class="default">var_export</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="string">'255.123.45.200'</span><span class="keyword">)); </span><span class="comment">// 1 (true)<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="111936">  
  <a class="name">
  <strong class="user"><em>horvath at webarticum dot hu</em></strong></a><div class="date" title="2013-04-15 12:09"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom111936">
<div class="phpcode"><code><span class="html">
Below are some reusable patterns. I used comments with the 'x' modifier for human-readability.<br><br>You can write also a function, that generates patterns for specified bracket/quote pairs.<br><br><span class="default">&lt;?php<br><br></span><span class="comment">/* normal paretheses */<br></span><span class="default">$simple_pattern </span><span class="keyword">= </span><span class="string">"(&nbsp; &nbsp; (?#root pattern)<br>&nbsp; (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#text or expression)<br>&nbsp; &nbsp; (?&gt;[^\\(\\)]+)&nbsp; &nbsp; &nbsp; (?#text)<br>&nbsp; &nbsp; |<br>&nbsp; &nbsp; \\((?-2)\\)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#expression and recursion)<br>&nbsp; )*<br>)"</span><span class="keyword">;<br><br></span><span class="default">$simple_okay_text </span><span class="keyword">= </span><span class="string">"5( 2a + (b - c) ) - a * ( 2b - (c * 3(b - (c + a) ) ) )"</span><span class="keyword">;<br></span><span class="default">$simple_bad_text </span><span class="keyword">= </span><span class="string">"5( 2)a + (b - c) ) - )a * ( ((2b - (c * 3(b - (c + a) ) ) )"</span><span class="keyword">;<br><br>echo </span><span class="string">"Simple pattern results:\n"</span><span class="keyword">;<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$simple_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_okay_text</span><span class="keyword">));<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$simple_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_bad_text</span><span class="keyword">));<br>echo </span><span class="string">"\n----------\n"</span><span class="keyword">;<br><br></span><span class="comment">/* some brackets */<br></span><span class="default">$full_pattern </span><span class="keyword">= </span><span class="string">"(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (?#root pattern)<br>&nbsp; (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#text or expression)<br>&nbsp; &nbsp; (?&gt;[^\\(\\)\\{\\}\\[\\]&lt;&gt;]+)&nbsp; &nbsp; (?#text not contains brackets)<br>&nbsp; &nbsp; |<br>&nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; [\\(\\{\\[&lt;]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (?#start bracket)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?(?&lt;=\\()(?-3)\\)|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if normal)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?(?&lt;=\\{)(?-3)\\}|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if coursed)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?(?&lt;=\\[)(?-3)\\]|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if squared)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?1)\\&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#else so if tag)<br>&nbsp; &nbsp; &nbsp; )))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#close nested-but-logically-the-some-level subpatterns)<br>&nbsp; &nbsp; )<br>&nbsp; )*<br>)"</span><span class="keyword">;<br><br></span><span class="default">$full_okay_text </span><span class="keyword">= </span><span class="string">"5( 2a + [b - c] ) - a * ( 2b - {c * 3&lt;b - (c + a) &gt; } )"</span><span class="keyword">;<br></span><span class="default">$full_bad_text </span><span class="keyword">= </span><span class="string">"5[ 2a + [b - c} ) - a * ( 2b - [c * 3(b - c + a) ) ) }"</span><span class="keyword">;<br><br>echo </span><span class="string">"Full pattern results:\n"</span><span class="keyword">;<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$full_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_okay_text</span><span class="keyword">));<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$full_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$full_okay_text</span><span class="keyword">));<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$full_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$full_bad_text</span><span class="keyword">));<br>echo </span><span class="string">"\n----------\n"</span><span class="keyword">;<br><br></span><span class="comment">/* some brackets and quotes */<br></span><span class="default">$extrafull_pattern </span><span class="keyword">= </span><span class="string">"(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#root pattern)<br>&nbsp; (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#text or expression)<br>&nbsp; &nbsp; (?&gt;[^\\(\\)\\{\\}\\[\\]&lt;&gt;'\"]+) (?#text not contains brackets and quotes)<br>&nbsp; &nbsp; |<br>&nbsp; &nbsp; (<br>&nbsp; &nbsp; &nbsp; ([\\(\\{\\[&lt;'\"])&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#start bracket)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?(?&lt;=\\()(?-4)\\)|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if normal)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?(?&lt;=\\{)(?-4)\\}|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if coursed)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?(?&lt;=\\[)(?-4)\\]|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if squared)<br>&nbsp; &nbsp; &nbsp; &nbsp; (?(?&lt;=\\&lt;)(?-4)\\&gt;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#if tag)<br>&nbsp; &nbsp; &nbsp; &nbsp; ['\"]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (?#else so if static)<br>&nbsp; &nbsp; &nbsp; ))))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (?#close nested-but-logically-the-some-level subpatterns)<br>&nbsp; &nbsp; )<br>&nbsp; )*<br>)"</span><span class="keyword">;<br><br></span><span class="default">$extrafull_okay_text </span><span class="keyword">= </span><span class="string">"5( 2a + ['b' - c] ) - a * ( 2b - \"{c * 3&lt;b - (c + a) &gt; }\" )"</span><span class="keyword">;<br></span><span class="default">$extrafull_bad_text </span><span class="keyword">= </span><span class="string">"5( 2a + ['b' - c] ) - a * ( 2b - \"{c * 3&lt;b - (c + a) &gt; }\" )"</span><span class="keyword">;<br><br>echo </span><span class="string">"Extra-full pattern results:\n"</span><span class="keyword">;<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$simple_okay_text</span><span class="keyword">));<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$full_okay_text</span><span class="keyword">));<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$extrafull_okay_text</span><span class="keyword">));<br></span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">"/^</span><span class="default">$extrafull_pattern</span><span class="string">\$/x"</span><span class="keyword">,</span><span class="default">$extrafull_bad_text</span><span class="keyword">));<br><br></span><span class="comment">/*<br><br>Outputs:<br><br>Simple pattern results:<br>int(0)<br>int(0)<br><br>----------<br>Full pattern results:<br>int(0)<br>int(0)<br>int(0)<br><br>----------<br>Extra-full pattern results:<br>int(0)<br>int(0)<br>int(0)<br>int(0)<br><br>*/<br><br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div></div>

 
</section>    </section><!-- layout-content -->
        


  </div><!-- layout -->

  

    
 <!-- External and third party libraries. -->
 







<a id="toTop" href="javascript:;"><span id="toTopHover"></span><img width="40" height="40" alt="To Top" src="../../images/to-top%402x.png"></a>



<!-- Mirrored from www.php.net/manual/en/regexp.reference.recursive.php by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 11 Sep 2021 10:47:49 GMT -->

</body></html>